<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello World!</title>
        <link>https://insomn14.github.io/posts/</link>
        <description>Recent content in Posts on Hello World!</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>insomn14</copyright>
        <lastBuildDate>Mon, 16 Nov 2020 05:56:50 +0700</lastBuildDate>
        <atom:link href="https://insomn14.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>CyberJawara2020 | RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/cyberjawara2020_writeup/</link>
            <pubDate>Mon, 16 Nov 2020 05:56:50 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/cyberjawara2020_writeup/</guid>
            <description>BabyBaby Description Binary ini dapat digunakan untuk permulaan belajar reverse engineering. Tips: Soal ini lebih mudah dikerjakan dengan static analysis seperti menggunakan Ghidra (gratis) atau IDA Pro (berbayar) dengan meng-generate kode C-like dari kode mesin yang ada di dalam binary. Problem Pada tantangan ini kita diberikan file binary BabyBaby, dan berikut ini adalah pseudocode dari fungsi main program tersebut.
 sym.imp.printf(0x9e4); // ps @ 0x9e4 = &amp;quot;Masukkan 3 angka:&amp;quot; sym.</description>
            <content type="html"><![CDATA[<hr>
<!-- raw HTML omitted -->
<h1 id="babybaby">BabyBaby</h1>
<h3 id="description">Description</h3>
<pre><code>Binary ini dapat digunakan untuk permulaan belajar reverse engineering.

Tips: Soal ini lebih mudah dikerjakan dengan static analysis seperti menggunakan Ghidra (gratis) atau IDA Pro (berbayar) dengan meng-generate kode C-like dari kode mesin yang ada di dalam binary.
</code></pre><h3 id="problem">Problem</h3>
<p>Pada tantangan ini kita diberikan file binary <em><a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/BabyBaby/BabyBaby">BabyBaby</a></em>, dan berikut ini adalah pseudocode dari fungsi main program tersebut.</p>
<pre><code>    sym.imp.printf(0x9e4);                                      //  ps @ 0x9e4 = &quot;Masukkan 3 angka:&quot;
    sym.imp.__isoc99_scanf(0x9f7, &amp;c, &amp;var_14h);                //  ps @ 0x9f7 = &quot;%d %d %d&quot;
    if (((c + var_14h == (uint32_t)var_10h * c) &amp;&amp;
        ((int32_t)var_14h / (int32_t)(uint32_t)var_10h == 0x14)) &amp;&amp;
        ((int32_t)var_14h / (int32_t)c == 3)) {
        var_10h._4_4_ = 0;
        sym.imp.puts(0xa00, c, (int32_t)var_14h % (int32_t)c);  //  ps @ 0xa00 = &quot;Benar!&quot;
        var_10h._4_4_ = 0;
        while (var_10h._4_4_ &lt; 0x15) {
            if (var_10h._4_4_ % 3 == 0) {
                sym.imp.putchar(c ^ *(uint32_t *)(&quot;X&quot; + (int64_t)var_10h._4_4_ * 4));
            }
            if (var_10h._4_4_ % 3 == 1) {
                sym.imp.putchar(var_14h ^ *(uint32_t *)(&quot;X&quot; + (int64_t)var_10h._4_4_ * 4));
            }
            if (var_10h._4_4_ % 3 == 2) {
                sym.imp.putchar((uint32_t)var_10h ^ *(uint32_t *)(&quot;X&quot; + (int64_t)var_10h._4_4_ * 4));
            }
            var_10h._4_4_ = var_10h._4_4_ + 1;
        }
    } else {
        sym.imp.puts(0xa07);        //  ps @ 0xa07 = &quot;Salah!&quot; 
    }
</code></pre><p><em>Pengecekan kondisi :</em></p>
<pre><code>if ((first + third == second * first)
&amp;&amp; (third / second == 0x14)
&amp;&amp; (third / first == 3))
</code></pre><p>Seperti yang kita lihat <code>scanf</code> menerima 3 masukan sebagai integer, masing-masing masukan akan dihitung dalam kondisi <code>if</code>. jika hasilnya <code>true</code> maka
program akan mencetak string <em>&ldquo;Benar&rdquo;</em> dan juga <em>Flag</em>.</p>
<h3 id="solution">Solution</h3>
<p>Untuk menyelesaikan tantangan ini kita dapat menggunakan library python z3-solver.</p>
<pre><code>&gt;&gt;&gt; from z3 import *
&gt;&gt;&gt; 
&gt;&gt;&gt; inp = [BitVec(f'input_{i}',8)for i in range(1,4)]
&gt;&gt;&gt; 
&gt;&gt;&gt; s = Solver()
&gt;&gt;&gt; s.add(inp[0] + inp[1] == inp[0] * inp[2], inp[1] / inp[2] == 20, inp[1] / inp[0] == 3)
&gt;&gt;&gt; s.check()
sat
&gt;&gt;&gt; s.model()
[input_2 = 81, input_3 = 4, input_1 = 27]
</code></pre><pre><code>┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/BabyBaby]
└─$ ./BabyBaby 
Masukkan 3 angka: 27 81 4
Benar!
CJ2020{b4A4a4BBbb7yy}
</code></pre><p>FLAG : <code>CJ2020{b4A4a4BBbb7yy}</code></p>
<hr>
<h1 id="holmes-code">Holmes Code</h1>
<h3 id="description-1">Description</h3>
<pre><code>This Code Secret Dr. Watson to Holmes, Please check message on the Code
</code></pre><h3 id="problem-1">Problem</h3>
<p>Pada tantangan kali ini kita diberikan file <em><a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Holmes%20Code/code.zip">code.zip</a></em> yang berisi file binary sejumlah <em>287</em> file. Berikut ini adalah sedikit potongan disassembly dari beberapa program binary tersebut.</p>
<pre><code>┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ objdump -d -M intel code0
  ...
00000000006000b0 &lt;.shellcode&gt;:
  ...
  6000c2:       48 8b 44 24 10          mov    rax,QWORD PTR [rsp+0x10]
  6000c7:       8a 10                   mov    dl,BYTE PTR [rax]
  6000c9:       80 ea 1e                sub    dl,0x1e
  6000cc:       80 fa ec                cmp    dl,0xec
  ...

┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ objdump -d -M intel code1
  ...
00000000006000b0 &lt;.shellcode&gt;:
  ...
  6000c2:       48 8b 44 24 10          mov    rax,QWORD PTR [rsp+0x10]
  6000c7:       8a 10                   mov    dl,BYTE PTR [rax]
  6000c9:       80 ea 35                sub    dl,0x35
  6000cc:       80 fa 1f                cmp    dl,0x1f
  ...

┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ objdump -d -M intel code2
  ...
00000000006000b0 &lt;.shellcode&gt;:
  ...
  6000c2:       48 8b 44 24 10          mov    rax,QWORD PTR [rsp+0x10]
  6000c7:       8a 10                   mov    dl,BYTE PTR [rax]
  6000c9:       80 c2 19                add    dl,0x19
  6000cc:       80 fa 81                cmp    dl,0x81
  ...
</code></pre><p>Setelah diamati ternyata setiap binary memiliki alur kode program yang mirip, namun masing-masing binary memiliki instruksi aritmatika yang berbeda-beda diantaranya <em>(add/sub/xor)</em>.</p>
<h3 id="solution-1">Solution</h3>
<p>Langkah-langkah yang perlu dilakukan untuk menyelesaikan tantangan ini:</p>
<ol>
<li>Membuat <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Holmes%20Code/solve.sh">bash script</a> untuk mengabil potongan kode dissassembly yang dibutuhkan.</li>
</ol>
<pre><code>┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ ./solve.sh &gt; data.txt

┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ head data.txt
code0
  6000c9:       80 ea 1e                sub    dl,0x1e
  6000cc:       80 fa ec                cmp    dl,0xec
code1
  6000c9:       80 ea 35                sub    dl,0x35
  6000cc:       80 fa 1f                cmp    dl,0x1f
code2
  6000c9:       80 c2 19                add    dl,0x19
  6000cc:       80 fa 81                cmp    dl,0x81
code3
</code></pre><ol start="2">
<li>Membuat <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Holmes%20Code/solver.py">python script</a> untuk menyelesikan tantangan berdasarkan kode disassembly yang sudah kita dapatkan sebelumnya.</li>
</ol>
<pre><code>┌──(unknow㉿unknow)-[~/…/CJ2020/Reverse/Holmes Code/code]
└─$ python solver.py

The story is notable for introducing the character of Irene Adler, who is one of the most notable female characters in the Sherlock Holmes series, despite appearing in only one story.[1] Doyle ranked CJ2020{A_ScaNdal_in_B0h3mia} fifth in his list of his twelve favourite Holmes stories.
</code></pre><p>FLAG : <code>CJ2020{A_ScaNdal_in_B0h3mia}</code></p>
<hr>
<h1 id="home-sherlock">Home Sherlock</h1>
<h3 id="description-2">Description</h3>
<pre><code>Number Home Sherlock Holmes ?

Please check on the File

Download home : https://drive.google.com/file/d/14P7xZ4XIsEm6HU5WMvOVw6E0BFRH6CuH/view
</code></pre><h3 id="problem-2">Problem</h3>
<p>Di tantangan kali ini kita diberikan file binary dari golang <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Home%20Sherlock/home"><em>home</em></a>. Berikut ini adalah pseudocode dari binary tersebut.</p>
<pre><code>[0x00454ed0]&gt; pdg@sym.main.main

void sym.main.main(int64_t arg1, int64_t arg2)
{
...
auStack24 = CONCAT88(0x4e9270, 0x4ab9c0);
    sym.fmt.Fprintln(arg1, arg2, (int64_t)obj.go.itab._os.File_io.Writer);
    sym.runtime.newobject();
    auStack40 = CONCAT88(placeholder_3, 0x4a5ca0);
    sym.fmt.Fscanln();
    if (*placeholder_3 == 0x9dbdf7f4c117ec) {
        sym.runtime.convTstring(arg1, arg2, arg3, placeholder_3, in_R8, in_R9);
        sym.fmt.Fprintln(arg1, arg2, arg3_00);
    } else {
        sym.fmt.Fprintln(arg1, arg2, arg3);
    }
    sym.fmt.Fscanln();
...
</code></pre><p>Jika file binary tersebut di eksekusi maka program akan meminta inputan, jika di perhatikan setelah pemanggilan fungsi <code>sym.fmt.Fscanln();</code> terdapat perbandingan perintah <code>if</code> yang membandingkan pointer <em>&quot;*placeholder_3&quot;</em> dengan nilai hexadesimal <em>&ldquo;0x9dbdf7f4c117ec&rdquo;</em>.</p>
<pre><code>
[0x00454ed0]&gt; pdf@sym.main.main
            ; CODE XREF from sym.main.main @ 0x4997a0
            ;-- sym.go.main.main:
┌ 597: sym.main.main (int64_t arg1, int64_t arg2);
...
...
│      │╎   0x00499643      48c744242001.  mov qword [var_20h], 1
│      │╎   0x0049964c      e8afa2ffff     call sym.fmt.Fscanln
│      │╎   0x00499651      48b8ec17c1f4.  movabs rax, 0x9dbdf7f4c117ec
│      │╎   0x0049965b      488b4c2440     mov rcx, qword [var_40h]
│      │╎   0x00499660      483901         cmp qword [rcx], rax
│     ┌───&lt; 0x00499663      0f85d5000000   jne 0x49973e
│     ││╎   0x00499669      488d052bb803.  lea rax, [0x004d4e9b]       ; &quot;Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQofile type does not support deadlinefindfunc: bad findfunctab entry idxfindrunnable: netpoll &quot;
│     ││╎   0x00499670      48890424       mov qword [rsp], rax
│     ││╎   0x00499674      48c744240823.  mov qword [var_8h], 0x23    ; '#'
...

[0x00454ed0]&gt; ps 35 @ 0x004d4e9b
Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQo
</code></pre><p>Pada saat kami melihat fungsi main dengan tampilan kode disassembly pada radare2, kita dapat melihat dengan jelas terdapat sebuah string yang aneh.</p>
<h3 id="solution-2">Solution</h3>
<p>Dari informasi yang sudah kita dapat sebelumnya selama melakukan static analysis, terdapat dua cara untuk menyelesaikan tantangan ini.</p>
<ol>
<li>Decode <em>&ldquo;Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQo&rdquo;</em> kedalam base64.</li>
</ol>
<pre><code>┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Home Sherlock]
└─$ echo 'Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQo' | base64 -d
CJ2020{221B_Baker_Str33t}
base64: invalid input
</code></pre><ol start="2">
<li>Ubah nilai hexadesimal <em>&ldquo;0x9dbdf7f4c117ec&rdquo;</em> kedalam desimal lalu jadikan sebagai inputan.</li>
</ol>
<pre><code>┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Home Sherlock]
└─$ python -c 'print(0x9dbdf7f4c117ec)'
44400444004440044

┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Home Sherlock]
└─$ ./home 
Sherlock Holmes Home
44400444004440044
Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQo

┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Home Sherlock]
└─$ echo 'Q0oyMDIwezIyMUJfQmFrZXJfU3RyMzN0fQo' | base64 -d
CJ2020{221B_Baker_Str33t}
base64: invalid input
</code></pre><p>FLAG : <code>CJ2020{221B_Baker_Str33t}</code></p>
<hr>
<h1 id="pawon">Pawon</h1>
<h3 id="description-3">Description</h3>
<pre><code>Yet another reverse engineering challenge
</code></pre><h3 id="problem-3">Problem</h3>
<p>Pada tantangan berikut ini kita diberikan file binary <em><a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Pawon/pawon">pawon</a></em>, dan berikut ini adalah potongan pseudocode kode dari fungsi <code>main</code> program tersebut yang sudah saya modif sedikit.</p>
<pre><code>...
    sym.banner();
    sym.imp.printf(&quot; Enter Your Mail\n &gt; &quot;);
    sym.imp.std::basic_istream_char__std::(reloc.std::cin, &amp;s);

    sym.imp.printf(&quot; Enter Serial\n &gt; &quot;);
    sym.imp.std::basic_istream_char__std::(reloc.std::cin);

    var_18h._0_4_ = 0;
    while( true ) {
        uVar7 = SEXT48((int32_t)var_18h);
        uVar3 = sym.imp.strlen(&amp;s);
        if (uVar3 &lt;= uVar7) break;
        if (*(char *)((int64_t)&amp;s + (int64_t)(int32_t)var_18h) == '@') {
            var_18h._7_1_ = '\x01';
        }
        var_18h._0_4_ = (int32_t)var_18h + 1;
    }
    if (var_18h._7_1_ == '\x01') {
        uVar3 = sym.imp.strlen(&amp;s);
        if (3 &lt; uVar3) goto code_r0x0000138d;
    }
    sym.seret();
...
</code></pre><p>Ketika saat mengeksekusi program tersebut kita akan diminta untuk memasukan dua inputan, yaitu <em>Mail</em> dan <em>Serial</em>. Terdapa pengecekan <em>Mail</em> yang mana inputan kita harus memiliki karakter <em>&quot;@&quot;</em> dan panjangnya harus lebih dari 3.</p>
<pre><code>...
code_r0x0000138d:
    uVar3 = sym.imp.strlen();
    if (uVar3 &lt; 0x19) {
        sym.seret();
    }
    if (((var_430h._5_1_ != '-') &amp;&amp; (var_425h != '-')) &amp;&amp; (var_41eh != '-')) {
        sym.seret();
    }
    if ((char)var_430h != var_426h) {
        sym.seret();
    }
    if (var_430h._1_1_ != 'e') {
        sym.seret();
    }
    if (var_430h._3_1_ != 'P') {
        sym.seret();
    }
    if ((char)var_417h != '\0') {
        sym.seret();
    }
    if (var_430h._2_1_ != 'm') {
        sym.seret();
    }
    if (var_430h._4_1_ != var_430h._1_1_) {
        sym.seret();
    }
    if (var_430h._6_1_ != 'j') {
        sym.seret();
    }
    if (var_430h._7_1_ != 'o') {
        sym.seret();
    }
    if (var_428h != var_427h) {
        sym.seret();
    }
    if (var_427h != 'S') {
        sym.seret();
    }
    cVar2 = sym.check_char__char__int
                      ((uint64_t)(uint32_t)(int32_t)var_430h._5_1_, (uint64_t)(uint32_t)(int32_t)var_424h, 9);
    if (cVar2 != '\x01') {
        sym.seret();
    }
    if ((int32_t)var_419h != var_41fh + 3) {
        sym.seret();
    }
    if (var_423h != var_41ch) {
        sym.seret();
    }
    if (var_422h != 'z') {
        sym.seret();
    }
    cVar2 = sym.check_char__char__int
                      ((uint64_t)(uint32_t)(int32_t)var_421h, (uint64_t)(uint32_t)(int32_t)var_420h, 0xffffff7a);
    if (cVar2 != '\x01') {
        sym.seret();
    }
    if (var_41bh != 'T') {
        sym.seret();
    }
    if (var_420h != 'H') {
        sym.seret();
    }
    if (var_41ch != 'u') {
        sym.seret();
    }
    if (var_41fh != '5') {
        sym.seret();
    }
    if (var_41dh != 'S') {
        sym.seret();
    }
    if (var_41ah != '1') {
        sym.seret();
    }
    if (var_426h != var_41bh) {
        sym.seret();
    }
    cVar2 = sym.check_char__char__int
                      ((uint64_t)(uint32_t)(int32_t)var_418h, (uint64_t)(uint32_t)(int32_t)var_41ch, 0xffffffc3);
    if (cVar2 != '\x01') {
        sym.seret();
    }
</code></pre><p>Bagian ini adalah pengecekan dari inputan <em>Serial</em>.</p>
<h3 id="solution-3">Solution</h3>
<p>Sama seperti tantangan <em>BabyBaby</em> yang sebelumnya, untuk menyelesaikan tantangan ini kita dapat menggunakan library python z3-solver.</p>
<p><a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Pawon/solver.py">solver.py</a></p>
<pre><code>┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Pawon]
└─$ python solver.py
TemPe-joSST-cuzgH5-SuT18­Y
                                                                           
┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Pawon]
└─$ ./pawon
          -------                
          CJ 2020                
          -------                
 Enter Your Mail
 &gt; test@mail.com
 Enter Serial
 &gt; TemPe-joSST-cuzgH5-SuT18Y

  CJ2020{r+jKctQn&amp;m14l,.JBH8WckZj}
</code></pre><p>FLAG : <code>CJ2020{r+jKctQn&amp;m14l,.JBH8WckZj}</code></p>
<hr>
<h1 id="ransomnware">Ransomnware</h1>
<h3 id="description-4">Description</h3>
<pre><code>Reverse engineering berguna untuk mengetahui alur dari suatu program baik untuk riset binary exploitation, membuat crack/patch, membuat keygen, ataupun analisis malware.

Berikut adalah sebuah ransomware yang mengenkripsi berkas flag.txt. Dapatkah Anda mendekripsi berkas tersebut?
</code></pre><h3 id="problem-4">Problem</h3>
<p>Pada tantangan ini kita diberikan file binary <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Ransomnware/ransomnware"><em>ransomnware</em></a> dan juga sebuah file <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Ransomnware/flag.txt.enc"><em>flag</em></a> yang telah terenkripsi. Berikut ini adalah potongan-potongan pseudocode dari file binary tersebut.</p>
<p><strong>Catatan : beberapa nama fungsi dan variabel telah kami ubah agar lebih mudah dibaca.</strong></p>
<pre><code>[0x000006e0]&gt; pdg @ randomVal
void randomVal(int64_t arg1)
{
    ...    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    fildes._0_4_ = sym.imp.open(0xcd5, 0);      // /dev/urandom
    sym.imp.read((undefined4)fildes, (int64_t)&amp;fildes + 4, 0x20, (int64_t)&amp;fildes + 4);
    sym.imp.close((undefined4)fildes);
    *(int64_t *)arg1 = stack0xffffffffffffffc8;
    *(void **)(arg1 + 8) = var_28h;
    *(int64_t *)(arg1 + 0x10) = Flag;
    *(int64_t *)(arg1 + 0x18) = var_18h;
    ...
}
</code></pre><pre><code>[0x000006e0]&gt; pdg @ fillArr
undefined8 fillArr(void)
{
    undefined8 I;
    
    I = 0;
    while (I &lt; 0x100) {
        *(FillArray + I) = I;
        I = I + 1;
    }
    *VAR_1 = 0;
    *VAR_2 = 0;
    return 1;
}
</code></pre><pre><code>[0x000006e0]&gt; pdg @ swapVal
void swapVal(int64_t arg1, int64_t arg2)
{
    ...    
    uVar1 = *(undefined *)arg1;
    *(undefined *)arg1 = *(undefined *)arg2;
    *(undefined *)arg2 = uVar1;
    return;
}
</code></pre><pre><code>[0x000006e0]&gt; pdg @ procSwap
void procSwap(int64_t arg1, int64_t arg2)
{
    ...
    *VAR_2 = 0;
    while (*VAR_2 &lt; 0x100) {
        iVar2 = *(FillArray + VAR_2) + *VAR_1 + *(arg1 + *VAR_2 % arg2);
        uVar1 = (iVar2 &gt;&gt; 0x1f) &gt;&gt; 0x18;
        *VAR_1 = (iVar2 + uVar1 &amp; 0xff) - uVar1;
        swapVal(*(FillArray + VAR_2), *(FillArray + *VAR_1));
        *VAR_2 = *VAR_2 + 1;
    }
    *VAR_1 = 0;
    *VAR_2 = 0;
    return;
}
</code></pre><pre><code>[0x000006e0]&gt; pdg @ main
undefined8 main(undefined8 argc, char **argv)
{
    ...
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    Flag._0_4_ = 1;
    Flag._4_4_ = sym.imp.open(&quot;flag.txt&quot;, 0);
    if (Flag._4_4_ == -1) {
    // WARNING: Subroutine does not return
        sym.imp.exit(0xffffffff);
    }
    FlagEnc = sym.imp.open(&quot;flag.txt.enc&quot;, 0x41);
    if (FlagEnc == 0xffffffff) {
    // WARNING: Subroutine does not return
        sym.imp.exit(0xffffffff);
    }

    randomVal(RandArr);
    var_14h = 0x20;
    fillArr();
    procSwap(*0x202010, 0x10); // 0x202010 -&gt; &quot;rhcmem__c\xadem__\xdaC&quot;
    ...
</code></pre><p>Setelah binary memuat file <code>flag.txt</code> dan <code>flag.txt.enc</code>, program memanggil fungsi <code>randomVal(RandArr);</code> yang mana variabel <code>RandArr</code> akan menyimpan nilai random sepanjang 32 byte dari <code>/dev/urandom</code>.</p>
<p>Berikutnya fungsi <code>fillArr();</code> akan membuat sebuah array yang memiliki nilai 0 s/d 255 dan disimpan pada <code>FillArray</code>.</p>
<p>Selanjutnya terdapat pemanggilan fungsi <code>procSwap(0x202010,16)</code>, pada fungsi ini setiap index dari <code>FillArray</code> akan calculated 32 byte dari <code>0x202010</code>, lalu dengan <code>swapVal</code> setiap indeks pada <code>FillArray</code> posisinya akan ditukar.</p>
<pre><code>[0x000006e0]&gt; pdg @ getValFromArr
undefined getValFromArr(void)
{
    uint32_t uVar1;
    
    uVar1 = (*VAR_2 + 1 &gt;&gt; 0x1f) &gt;&gt; 0x18;
    *VAR_2 = (*VAR_2 + 1 + uVar1 &amp; 0xff) - uVar1;
    *VAR_1 = *(FillArray + VAR_2) + *VAR_1;
    uVar1 = (*VAR_1 &gt;&gt; 0x1f) &gt;&gt; 0x18;
    *VAR_1 = (*VAR_1 + uVar1 &amp; 0xff) - uVar1;
    swapVal(*(FillArray + VAR_2), *(FillArray + VAR_1));
    return *(FillArray (*(FillArray + VAR_1) + *(FillArray + VAR_2)));
}
</code></pre><pre><code>    ...
    var_14h = 16;
    ...
    J = 0;
    while (J &lt; (int32_t)var_14h) {
        var_25h = getValFromArr();
        ptr = *(RandArr + J) ^ var_25h;
        sym.imp.write(FlagEnc, &amp;ptr, 1);
        J = J + 1;
    }
    fillArr();
    procSwap(RandArr, var_14h);
    while( true ) {
        Flag._0_4_ = sym.imp.read(Flag._4_4_, &amp;buf, 1, &amp;buf);
        if ((int32_t)Flag &lt; 1) break;
        var_25h = getValFromArr();
        ptr = buf ^ var_25h;
        sym.imp.write(FlagEnc, &amp;ptr, 1, &amp;ptr);
    }
    sym.imp.close(Flag._4_4_);
    sym.imp.close(FlagEnc);
    ...
</code></pre><p>Pada bagian ini terdapat looping sebanyak 16x, dimana setiap indeks yang ada pada <code>RandArr</code> akan di XOR dengan nilai yang didapat dari fungsi <code>getValFromArr();</code>. Setiap nilai yang ada pada indeks <code>FillArray</code> akan swap, setiap kali terjadi pemanggilan pada fungsi <code>getValFromArr();</code>. Setiap hasil XOR antara <code>RandArr</code> dan <code>var_25h</code> akan ditulis pada <code>FlagEnc</code>.</p>
<p>Selanjutnya terdapat pemanggialn fungsi <code>fillArr();</code> dan <code>procSwap(RandArr,var_14h);</code>, kurang lebih penjelasnya hampir sama dengan yang sebelumnya. Namun kali ini variabel setiap indeks <code>FillArray</code> akan di calculated dengan 32 byte dari <code>RandArr</code>, kemudian setiap indeksnya akan swap dengan fungsi <code>swapVal</code>.</p>
<p>Berikutnya terdapat looping dimana <code>buf</code> akan menyimpan setiap 1byte dari <code>Flag._4_4_</code>. Kemudian <code>buf</code> di XOR dengan <code>var_25h</code> yang nilainya didapat dari <code>getValFromArr();</code>, hasil calculated <code>buf</code> dan <code>var_25h</code> akan ditulis pada <code>FlagEnc</code>.</p>
<h3 id="solution-4">Solution</h3>
<p>Cara untuk mendekripsi :</p>
<ol>
<li>
<p>Membuat array[256].</p>
</li>
<li>
<p>Melakukan perhitungan setiap indeks pada array[256] dengan <code>0x202010</code>.</p>
</li>
<li>
<p>Swap setiap posisi yang ada pada array[256].</p>
</li>
<li>
<p>Mengambil nilai dari array[256], lalu array[256] di swap kembali.</p>
</li>
<li>
<p>Melakukan xoring terhadap 32 byte pertama dari <a href="flag.txt.enc"><em>flag</em></a> dengan nilai yang telah dapat dari array[256].</p>
<p><strong>Catatan: kita telah berhasil mengembalikan nilai 32 byte dari  <code>/dev/random</code></strong></p>
</li>
<li>
<p>Ulangi kembali langkah 1 s/d 4. Namun pada langkah kedua array[256] akan di perhitungkan dengan <code>/dev/urandom</code> yang telah kita dapatkan sebelumnya.</p>
</li>
<li>
<p>Melakukan xoring terhadap sisa dari 32 byte pertama pada <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Ransomnware/flag.txt.enc"><em>flag</em></a> dengan nilai yang kita dapat dari array[256].</p>
<p><strong>Catatan: selamat kita telah berhasil mengembalikan <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Ransomnware/flag.txt.enc"><em>flag</em></a> seperti semula</strong></p>
</li>
</ol>
<p>Berikut ini adalah hasil dari <a href="https://github.com/insomn14/CTFindo/blob/master/2020/CJ2020/Reverse/Ransomnware/solver.py">solver</a> saya.</p>
<pre><code>┌──(unknow㉿unknow)-[~/…/2020/CJ2020/Reverse/Ransomnware]
└─$ python solver.py 
CJ2020{mamntap_gan_c71c416369bb6230}

</code></pre><p>FLAG : <code>CJ2020{mamntap_gan_c71c416369bb6230}</code></p>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>rgbCTF2020 | RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/rgbctf2020/</link>
            <pubDate>Tue, 14 Jul 2020 16:09:06 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/rgbctf2020/</guid>
            <description>Too Slow 50pts I&#39;ve made this flag decryptor! It&#39;s super secure, but it runs a little slow. ~ungato#3536 a.out Size: 16.46KB MD5: 0552728acb42e5f59c2ff3e8dcafc04d In this challenge we are given an a.out binary file.
❯ file a.out a.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=462dfe207acdfe1da2133cac6b69b45de5169ee2, for GNU/Linux 3.2.0, not stripped ❯ ./a.out Flag Decryptor v1.0 Generating key... ^C If we execute the file, the program only runs without stopping.</description>
            <content type="html"><![CDATA[<hr>
<h3 id="too-slow-50pts">Too Slow 50pts</h3>
<pre><code>I've made this flag decryptor! It's super secure, but it runs a little slow.


~ungato#3536
a.out Size: 16.46KB  MD5: 0552728acb42e5f59c2ff3e8dcafc04d
</code></pre><p>In this challenge we are given an <a href="https://github.com/insomn14/CTFtime2020/tree/master/rgbCTF2020/Pwn%26Rev/Too%20Slow%20%5B50pts%5D"><em>a.out</em></a> binary file.</p>
<pre><code>❯ file a.out
a.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=462dfe207acdfe1da2133cac6b69b45de5169ee2, for GNU/Linux 3.2.0, not stripped

❯ ./a.out
Flag Decryptor v1.0
Generating key...
^C
</code></pre><p>If we execute the file, the program only runs without stopping. Let&rsquo;s dive deeper into understanding the workings of the program.</p>
<pre><code>[0x000010a0]&gt; pdg@main

undefined8 main(undefined8 argc, char **argv)
{
    uint32_t uVar1;
    char **var_10h;
    int64_t var_4h;
    
    sym.imp.puts(&quot;Flag Decryptor v1.0&quot;);
    sym.imp.puts();
    uVar1 = sym.getKey();
    sym.win((uint64_t)uVar1);
    return 0;
}

[0x000010a0]&gt; pdg@sym.getKey

uint32_t sym.getKey(void)
{
    uint32_t var_8h;
    uint32_t var_4h;
    
    var_8h = 0;
    while (var_8h &lt; 0x265d1d23) {
        var_4h = var_8h;
        while (var_4h != 1) {
            if ((var_4h &amp; 1) == 0) {
                var_4h = (int32_t)var_4h / 2;
            } else {
                var_4h = var_4h * 3 + 1;
            }
        }
        var_8h = var_8h + 1;
    }
    return var_8h;
}
</code></pre><p>After looking at the pseudocode of the program, there are two interesting functions <code>getKey</code> &amp; <code>win</code>. In the <code>getKey</code> function there is a looping of <code>0x265d1d23</code>. If we note the <code>getKey</code> function will only return the result of the variable var_8h after increment, so the key would be <code>0x265d1d23</code>.</p>
<pre><code>
[0x000010a0]&gt; pdg@sym.win

void sym.win(int64_t arg1)
{
	...
	...

    iVar1 = *(int64_t *)(in_FS_OFFSET + 0x28);
    var_30h = (char *)0x12297e12426e6f53; // 0x42642a41473e425717696a7c49334216426e2e4d79242e48796e714112297e12426e6f53
    var_34h = 0;
    while (var_34h &lt; 9) {
        *(uint32_t *)((int64_t)&amp;var_30h + (uint64_t)var_34h * 4) =
             *(uint32_t *)((int64_t)&amp;var_30h + (uint64_t)var_34h * 4) ^ (uint32_t)arg1;
        var_34h = var_34h + 1;
    }
    sym.imp.printf(&quot;Your flag: rgbCTF{%36s}\n&quot;, &amp;var_30h);
    if (iVar1 != *(int64_t *)(in_FS_OFFSET + 0x28)) {
        sym.imp.__stack_chk_fail();
    }
    return;
}
</code></pre><p>In the <code>win</code> function every four bytes of the <code>var_30h</code> variable in xor with the key we got from the <code>getKey</code> function. Without the need to wait for a very long loop, let&rsquo;s make a simple script to solve this challenge.</p>
<pre><code>&gt;&gt;&gt; from Crypto.Util.number import bytes_to_long as btl
&gt;&gt;&gt; from Crypto.Util.number import long_to_bytes as ltb
&gt;&gt;&gt; 
&gt;&gt;&gt; xor = lambda x,y : b''.join(ltb(btl(enc[i*4:i*4+4]) ^ y)[::-1] for i in range(len(x)//4))
&gt;&gt;&gt; 
&gt;&gt;&gt; enc = ltb(0x42642a41473e425717696a7c49334216426e2e4d79242e48796e714112297e12426e6f53)
&gt;&gt;&gt; key = 0x265d1d23
&gt;&gt;&gt; 
&gt;&gt;&gt; xor(enc, key)
b'pr3d1ct4bl3_k3y_n33d5_no_w41t_cab79d'
</code></pre><p>FLAG : <code>rgbCTF{pr3d1ct4bl3_k3y_n33d5_no_w41t_cab79d}</code></p>
<hr>
<h3 id="advanced-reversing-mechanics-1-216pts">Advanced Reversing Mechanics 1 216pts</h3>
<pre><code>Very very advanced trust me
71, 66, 61, 42, 53, 45, 7A, 40, 51, 4C, 5E, 30, 79, 5E, 31, 5E, 64, 59, 5E, 38, 61, 36, 65, 37, 63, 7C

~ungato#3536
arm_easy.o Size: 1.40KB MD5: ee06c35e5e65c89fe91729dc5150bd19
</code></pre><p>In the following challenge we ARM binary file <a href="https://github.com/insomn14/CTFtime2020/tree/master/rgbCTF2020/Pwn%26Rev/Advanced%20Reversing%20Mechanics%201%20%5B216pts%5D"><em>arm_easy.o</em></a></p>
<pre><code>❯ file easy.o
easy.o: ELF 32-bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped
</code></pre><p>In this challenge I have a little problem because I don&rsquo;t know how to execute the program, so we have to do a static analysis. Let&rsquo;s look at the pseudocode of this program.</p>
<pre><code>[0x08000034]&gt; afl
0x08000034    3 36           sym.encryptFlag
0x08000058    7 124          sym.main

[0x08000034]&gt; pdg@sym.encryptFlag

void sym.encryptFlag(int32_t arg1)
{
    char cVar1;
    
    // [01] -r-x section size 36 named .text
    cVar1 = *(char *)arg1;
    if (cVar1 == '\0') {
        return;
    }
    do {
        *(char *)arg1 = cVar1 + -1;
        arg1 = arg1 + 1;
        cVar1 = *(char *)arg1;
    } while (cVar1 != '\0');
    return;
}
</code></pre><p>As you can see there is an encryptFlag function where the function receives an arg1 parameter and each character on arg1 is summed with -1. Btw on this challenge we are given an output, chances are it is a flag that has been encrypted using this program. Here is a simple script to solve this challenge.</p>
<pre><code>&gt;&gt;&gt; s = [0x71, 0x66, 0x61, 0x42, 0x53, 0x45, 0x7A, 0x40, 0x51, 0x4C, 0x5E, 0x30, 0x79, 0x5E, 0x31, 0x5E, 0x64, 0x59, 0x5E, 0x38, 0x61, 0x36, 0x65, 0x37, 0x63, 0x7C]
&gt;&gt;&gt; msg = ''.join(chr(i+1) for i in s)
&gt;&gt;&gt; msg
'rgbCTF{ARM_1z_2_eZ_9b7f8d}'
</code></pre><p>FLAG : <code>rgbCTF{ARM_1z_2_eZ_9b7f8d}</code></p>
<hr>
<h3 id="object-oriented-programming-413pts">Object Oriented Programming 413pts</h3>
<pre><code>There's this small up and coming language called java I want to tell you about


~Quintec#0689
src.zip Size: 6.85KB MD5: ea5c341ca73f54b8dd8f52e34403760a
</code></pre><p>In this challenge we are given the <a href="https://github.com/insomn14/CTFtime2020/tree/master/rgbCTF2020/Pwn%26Rev/Object%20Oriented%20Programming%20%5B413pts%5D"><em>src.zip</em></a> file which contains java programs. Let&rsquo;s extract and compile the challenge.</p>
<pre><code>❯ cd src
❯ ls
bv.java  cd.java  fg.java  gl.java  gq.java  gx.java  iy.java  Main.java
mo.java  pr.java  qa.java  qg.java  vh.java  wz.java  xp.java  xq.java
❯ javac *.java
❯ java Main
IO is online.

</code></pre><p>After a few hours of analyzing the source code of the program, I finally understood how to work from this challenge.</p>
<pre><code>	...
	public static final int SIXTEEN = BigInteger.valueOf(16).intValue();
	...

		String userInput = getUserInputMethodFromScannerAndInvokeAndReturnOutput(scanner);
		if (userInput.length() != SIXTEEN)
			System.exit(0);
		
		if (executeCodeThatDoesSomethingThatYouProbablyNeedToFigureOut(userInput).equals(scanner.getClass().getPackageName().replace(&quot;.&quot;, &quot;&quot;))) {
			invokePrintLineMethodForOutputPrintStream(outputPrintStream, printLineMethod, &quot;Nice. Flag: rgbCTF{&quot; + userInput + &quot;}&quot;);
		} else {
			invokePrintLineMethodForOutputPrintStream(outputPrintStream, printLineMethod, &quot;Try again.&quot;);
		}
</code></pre><p>As you can see the length of our input must be 16, the next step of our input will be compared with the package name of the <code>scanner</code> that is <code>javautil</code>. Before our input is compared with <code>javautil</code>, we must find out what the <code>executeCodeThatDoesSomethingThatYouProbablyNeedToFigureOut</code> method does with our input.</p>
<pre><code>	public static String executeCodeThatDoesSomethingThatYouProbablyNeedToFigureOut(String stringToExecuteAforementionedCodeOn) throws Exception {
		String encryptedString = reallyBasicQuoteUnquoteEncryptionFunctionThatWillOnlyTakeTimeToFigureOutIfYouKeepReadingTheseRidiculouslyLongMethodNames(stringToExecuteAforementionedCodeOn);
	...

	protected static char secureEncryptionKey; //it's protected, how you gonna crack it now?
	
	public static String reallyBasicQuoteUnquoteEncryptionFunctionThatWillOnlyTakeTimeToFigureOutIfYouKeepReadingTheseRidiculouslyLongMethodNames(String stringToQuoteUnquoteEncrypt) throws Exception {
		secureEncryptionKey = new EncryptionKeyInstantiator().getEncryptionKeyFactory().getEncryptionKey();
		Integer[] encryptedArrayToBeCalledByStringConstructor = new Integer[stringToQuoteUnquoteEncrypt.length()];
		for (int loopIndexIterator = ZERO; loopIndexIterator &lt; stringToQuoteUnquoteEncrypt.length(); loopIndexIterator++) {
			encryptedArrayToBeCalledByStringConstructor[loopIndexIterator] = stringToQuoteUnquoteEncrypt.charAt(loopIndexIterator)^secureEncryptionKey;
		}
</code></pre><p>After being in the <code>executeCodeThatDoesSomethingThatYouProbablyNeedToFigureOut</code> method our input is sent to the <code>reallyBasicQuoteUnquoteEncryptionFunctionThatWillOnlyTakeTimeToFigureOutIfYouKeepRead...</code>, method, The possibility of first seeing the source code of this challenge will be a little confusing because of the strange method names and variables, but in fact this is just a simple program. As you can see there are the <code>secureEncryptionKey</code> and for loop variables, where each of our input characters will be xor with <code>secureEncryptionKey</code>. To find out the value of <code>secureEncryptionKey</code> I made a few changes to the source code to display the value of <code>secureEncryptionKey</code>.</p>
<pre><code>	public static String reallyBasicQuoteUnquoteEncryptionFunctionThatWillOnlyTakeTimeToFigureOutIfYouKeepReadingTheseRidiculouslyLongMethodNames(String stringToQuoteUnquoteEncrypt) throws Exception {
		secureEncryptionKey = new EncryptionKeyInstantiator().getEncryptionKeyFactory().getEncryptionKey();
		System.out.println(&quot;Key : &quot;+(int)secureEncryptionKey);    // &lt;----- A little change
		Integer[] encryptedArrayToBeCalledByStringConstructor = new Integer[stringToQuoteUnquoteEncrypt.length()];
		for (int loopIndexIterator = ZERO; loopIndexIterator &lt; stringToQuoteUnquoteEncrypt.length(); loopIndexIterator++) {
			encryptedArrayToBeCalledByStringConstructor[loopIndexIterator] = stringToQuoteUnquoteEncrypt.charAt(loopIndexIterator)^secureEncryptionKey;
		}

// Recompile the program and execute again
❯ javac *.java
❯ java Main
IO is online.
AAAAAAAAAAAAAAAA
Key : 2
Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: CC
	...
</code></pre><p>Now that we know that our input will be xored with a value of 2, okay let&rsquo;s continue the analysis of the previous method.</p>
<pre><code>...
public static final int TWO = BigInteger.valueOf(2).intValue();
public static final int FOUR = BigInteger.valueOf(4).intValue();
...

public static String executeCodeThatDoesSomethingThatYouProbablyNeedToFigureOut(String stringToExecuteAforementionedCodeOn) throws Exception {
		String encryptedString = reallyBasicQuoteUnquoteEncryptionFunctionThatWillOnlyTakeTimeToFigureOutIfYouKeepReadingTheseRidiculouslyLongMethodNames(stringToExecuteAforementionedCodeOn);
		String returnValueOfThisFunction = new String();
		String[] chunksOfEncryptedStringOfLengthFour = splitStringIntoChunksOfLength(encryptedString, FOUR);
		...
</code></pre><p>The next step after our input is encrypted, our input will be split into four parts with the <code>splitStringIntoChunksOfLength</code> method,</p>
<pre><code>		...
		for (String chunkOfEncryptedStringOfLengthFour : chunksOfEncryptedStringOfLengthFour) {
			String[] chunksOfChunkOfEncryptedStringOfLengthFourOfLengthTwo = splitStringIntoChunksOfLength(chunkOfEncryptedStringOfLengthFour, TWO);
			String firstChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo = chunksOfChunkOfEncryptedStringOfLengthFourOfLengthTwo[0];
			String secondChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo = chunksOfChunkOfEncryptedStringOfLengthFourOfLengthTwo[1];
			Class&lt;?&gt; classAndExtraCharactersSoItsNotAKeyword = Class.forName(firstChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo);
			Object object = classAndExtraCharactersSoItsNotAKeyword.getConstructors()[ZERO].newInstance();
			for (int loopArbitraryCounterIterator = 0; loopArbitraryCounterIterator &lt; THREE; loopArbitraryCounterIterator++) {
				Method method = classAndExtraCharactersSoItsNotAKeyword.getMethod(secondChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo);
				secondChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo = (String)method.invoke(object);
			}
			returnValueOfThisFunction = new String(returnValueOfThisFunction + secondChunkOfChunkOfEncryptedStringOfLengthFourOfLengthTwo);
		}
		return returnValueOfThisFunction;
	}
</code></pre><p>After dividing it into four parts, our input will be further divided into two parts. In this section I will explain it briefly, where the first part defines a <em>Class</em> and the second part defines a <em>Method</em> and there is a loop for three times, the looping result will produce a string stored in the <code>returnValueOfThisFunction</code> variable and will be compared with the <code>javautil</code> string . So from here we have to choose the right <em>Class</em> and <em>Method</em> to produce a string as we want.</p>
<p>Following are my observations and simple scripts to solve this challenge.</p>
<pre><code>1. gl.vg().we().rb() = &quot;ja&quot;
2. pr.pk().te().wj() = &quot;va&quot;
3. qg.am().xs().mb() = &quot;ut&quot;
4. fg.gg().mg().oa() = &quot;il&quot;

input = &quot;glvgprpkqgamfggg&quot; ^ 2

&gt;&gt;&gt; xor = lambda x : ''.join(chr(ord(i) ^ 2) for i in x)
&gt;&gt;&gt; 
&gt;&gt;&gt; xor('glvgprpkqgamfggg')
'enterprisecodeee'
</code></pre><pre><code>❯ java Main
IO is online.
enterprisecodeee
Key : 2
Nice. Flag: rgbCTF{enterprisecodeee}
</code></pre><p>FLAG : <code>rgbCTF{enterprisecodeee}</code></p>
<hr>
<h3 id="sadistic-reversing-1-490pts">sadistic reversing 1 490pts</h3>
<pre><code>[114, 20, 119, 59, 104, 47, 75, 56, 81, 99, 23, 71, 56, 75, 124, 31, 65, 32, 77, 55, 103, 31, 96, 18, 76, 41, 27, 122, 29, 47, 83, 33, 78, 59, 10, 56, 15, 34, 94]

sadrev
</code></pre><p>In this challenge we are given a binary file <a href="https://github.com/insomn14/CTFtime2020/tree/master/rgbCTF2020/Pwn%26Rev/sadistic%20reversing%201%20%5B490pts%5D"><em>itJX.so</em></a> and an output in the description.</p>
<pre><code>❯ file itJX.so
itJX.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=14acf351a09cb300f6bb1d4f4cc474cd3009f525, for GNU/Linux 3.2.0, stripped
</code></pre><p>After a few hours analyzing the pseudocode of the program, I still did not know how the program works. For a moment I thought that the output possible in the description was a flag, so I tried using different inputs.</p>
<pre><code>❯ cat output.txt
[114, 20, 119, 59, 104, 47, 75, 56, 81, 99, 23, 71, 56, 75, 124, 31, 65, 32, 77, 55, 103, 31, 96, 18, 76, 41, 27, 122, 29, 47, 83, 33, 78, 59, 10, 56, 15, 34, 94]

❯ ./itJX.so aaaaa
[97, 3, 101, 7, 105]

❯ ./itJX.so rgbCTF
[114, 20, 119, 59, 104, 47]

❯ ./itJX.so rgbCTF{
[114, 20, 119, 59, 104, 47, 75]

❯ ./itJX.so rgbCTF{a
[114, 20, 119, 59, 104, 47, 75, 45]

❯ ./itJX.so rgbCTF{b
[114, 20, 119, 59, 104, 47, 75, 46]

❯ ./itJX.so rgbCTF{c
[114, 20, 119, 59, 104, 47, 75, 47]
</code></pre><p>As you can see when I try to enter &ldquo;rgbCTF​​{&rdquo; the result is the same as the output in the description, and when I add one character &lsquo;a, b, c&rsquo; the output is the same and does not affect the previous character. So we can do brute force to guess the next character.</p>
<p>The following is the output from my <a href="https://github.com/insomn14/CTFtime2020/blob/master/rgbCTF2020/Pwn%26Rev/sadistic%20reversing%201%20%5B490pts%5D/solver.py"><em>solver</em></a>.</p>
<pre><code>❯ python3 solver.py
Found : rgbCTF{th1s_pr0bably_w@s_d1ff1cult6362}
</code></pre><p>FLAG : <code>rgbCTF{th1s_pr0bably_w@s_d1ff1cult6362}</code></p>
<hr>
<h3 id="sadistic-reversing-2-496pts">sadistic reversing 2 496pts</h3>
<pre><code>hopefully harder now
[117, 148, 123, 5, 54, 9, 61, 234, 45, 4, 2, 40, 88, 111, 65, 65, 46, 23, 114, 110, 102, 148, 136, 123, 30, 5, 214, 231, 225, 255, 239, 138, 211, 208, 250, 232, 178, 187, 171, 242, 255, 30, 39, 19, 64, 17, 40, 29, 13, 27]

sadrev
</code></pre><p>The following challenge we are given a binary file <a href="https://github.com/insomn14/CTFtime2020/tree/master/rgbCTF2020/Pwn%26Rev/sadistic%20reversing%202%20%5B496pts%5D"><em>itwk.so</em></a> and output it in the description.</p>
<pre><code>❯ file itwk.so
itwk.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c701432ac4d8bbaffbcb1bca17fd413a4027f4a1, for GNU/Linux 3.2.0, stripped
</code></pre><p>Similar to the previous challenge of <code>sadistic reversing 1</code>, in this challenge we have to guess the right character.</p>
<pre><code>❯ ./itwk.so a
Exception in thread &quot;main&quot; java.lang.StringIndexOutOfBoundsException: String index out of range: -31
	at java.lang.String.substring(String.java:1841)
	at sadrev.leftrotate(sadrev.java:15)
	at sadrev.main(sadrev.java:21)

❯ ./itwk.so aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 245, 239, 228, 52, 61, 233, 246, 228, 57, 57, 59, 34, 70, 46]

❯ ./itwk.so aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 245, 239, 228, 52, 61, 233, 246, 228, 57, 57, 59, 34, 70, 46, 122, 65, 117, 146, 193, 192, 34, 37, 30, 255, 244, 222, 132, 213, 223, 239, 251, 222]

❯ ./itwk.so rgbCTF{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 134, 154, 146, 96, 124, 143, 234, 248, 37, 37, 39, 62, 90, 50, 102, 93, 105, 142, 221, 220, 62, 57, 2, 227, 232, 194, 152, 201, 195, 243, 231, 194]
</code></pre><p>As you can see when I try to enter the character &lsquo;a&rsquo;, we get the message <em>Exception: index out of range: -31</em>. After adding 31 characters the program displays output without errors. But the output in the description is 50, so I add 18 more characters and combine it with the flag format. Even though I have combined it with the flag format, the program still produces the same output. If we look more closely, only 18 indexes produce the same output, even though the initial 7 characters have changed to &ldquo;rgbCTF{&rdquo;. So I decided to shoot the exact index location in the hope that the value of &lsquo;71&rsquo; changed.</p>
<pre><code>❯ ./itwk.so rgbCTF{baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 134, 154, 146, 96, 124, 143, 234, 251, 38, 38, 36, 61, 89, 49, 101, 94, 106, 141, 222, 223, 61, 58, 1, 224, 235, 193, 155, 202, 192, 240, 228, 193]
❯ ./itwk.so rgbCTF{abaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 134, 154, 146, 96, 124, 143, 234, 248, 38, 38, 36, 61, 89, 49, 101, 94, 106, 141, 222, 223, 61, 58, 1, 224, 235, 193, 155, 202, 192, 240, 228, 193]
❯ ./itwk.so rgbCTF{aabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 134, 154, 146, 96, 124, 143, 234, 248, 37, 38, 36, 61, 89, 49, 101, 94, 106, 141, 222, 223, 61, 58, 1, 224, 235, 193, 155, 202, 192, 240, 228, 193]
❯ ./itwk.so rgbCTF{aaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[71, 85, 79, 137, 143, 130, 133, 171, 107, 71, 51, 25, 98, 167, 142, 132, 230, 227, 134, 154, 146, 96, 124, 143, 234, 248, 37, 37, 36, 61, 89, 49, 101, 94, 106, 141, 222, 223, 61, 58, 1, 224, 235, 193, 155, 202, 192, 240, 228, 193]
...
...
❯ ./itwk.so rgbCTF{aaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa
[68, 86, 76, 138, 140, 129, 134, 168, 104, 68, 48, 26, 97, 164, 141, 135, 229, 224, 133, 153, 145, 99, 127, 140, 233, 251, 38, 38, 36, 61, 89, 49, 101, 94, 106, 141, 222, 223, 61, 58, 1, 224, 235, 193, 155, 202, 192, 240, 228, 193]
...
...
❯ ./itwk.so rgbCTF{aaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaa
[117, 103, 125, 187, 189, 176, 183, 153, 89, 117, 1, 43, 80, 149, 188, 182, 212, 209, 180, 168, 160, 82, 78, 189, 216, 202, 23, 23, 21, 12, 104, 0, 84, 111, 91, 188, 239, 238, 12, 11, 48, 209, 218, 240, 170, 251, 241, 193, 213, 240]
...
...
❯ ./itwk.so rgbCTF{aaaaaaaaaaaaaaaaaaaaaaaaa32aaaaaaaaaaaaaaaa
[117, 148, 142, 72, 78, 67, 68, 106, 170, 134, 242, 216, 163, 102, 79, 69, 39, 34, 71, 91, 83, 161, 189, 78, 43, 57, 228, 228, 230, 255, 155, 243, 167, 156, 168, 79, 28, 29, 255, 248, 195, 34, 41, 3, 89, 8, 2, 50, 38, 3]
</code></pre><p>After taking a long time, as you can see when the character &lsquo;b&rsquo; is in the index 33 the program displays the value &lsquo;68&rsquo;. After knowing the exact index the next step I tried to guess the right character and I got the character &lsquo;3&rsquo; having the same output as the description. Moving to the next index, the character &lsquo;2&rsquo; has the same output as the description.</p>
<p>After knowing the correct index we can do brute force for each index, the following is the output of my <a href="https://github.com/insomn14/CTFtime2020/blob/master/rgbCTF2020/Pwn%26Rev/sadistic%20reversing%202%20%5B496pts%5D/solver.py"><em>solver</em></a>.</p>
<pre><code>❯ python3 solver.py
Found : ********************************3*****************
Found : ********************************32****************
Found : ********************************324***************
Found : ********************************3249**************
Found : ********************************32494*************
Found : ********************************324943************
Found : ********************************3249432***********
Found : ********************************32494328**********
Found : ********************************32494328f*********
Found : ********************************32494328fd********
Found : ********************************32494328fds*******
Found : ********************************32494328fdsa******
Found : ********************************32494328fdsaj*****
Found : ********************************32494328fdsajs****
Found : ********************************32494328fdsajsf***
Found : ********************************32494328fdsajsfk**
Found : ********************************32494328fdsajsfkl*
Found : ********************************32494328fdsajsfkl}
Found : r*******************************32494328fdsajsfkl}
Found : rg******************************32494328fdsajsfkl}
Found : rgb*****************************32494328fdsajsfkl}
Found : rgbC****************************32494328fdsajsfkl}
Found : rgbCT***************************32494328fdsajsfkl}
Found : rgbCTF**************************32494328fdsajsfkl}
Found : rgbCTF{*************************32494328fdsajsfkl}
Found : rgbCTF{h************************32494328fdsajsfkl}
Found : rgbCTF{ho***********************32494328fdsajsfkl}
Found : rgbCTF{hop**********************32494328fdsajsfkl}
Found : rgbCTF{hope*********************32494328fdsajsfkl}
Found : rgbCTF{hopef********************32494328fdsajsfkl}
Found : rgbCTF{hopefu*******************32494328fdsajsfkl}
Found : rgbCTF{hopeful******************32494328fdsajsfkl}
Found : rgbCTF{hopefull*****************32494328fdsajsfkl}
Found : rgbCTF{hopefully****************32494328fdsajsfkl}
Found : rgbCTF{hopefully_***************32494328fdsajsfkl}
Found : rgbCTF{hopefully_t**************32494328fdsajsfkl}
Found : rgbCTF{hopefully_th*************32494328fdsajsfkl}
Found : rgbCTF{hopefully_thi************32494328fdsajsfkl}
Found : rgbCTF{hopefully_this***********32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_**********32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_w*********32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_wa********32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was*******32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_******32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_h*****32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_ha****32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_har***32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_hard**32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_harde*32494328fdsajsfkl}
Found : rgbCTF{hopefully_this_was_harder32494328fdsajsfkl}
</code></pre><p>FLAG : <code>rgbCTF{hopefully_this_was_harder32494328fdsajsfkl}</code></p>
]]></content>
        </item>
        
        <item>
            <title>redpwn 2020 | RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/redpwn-2020/</link>
            <pubDate>Fri, 26 Jun 2020 12:56:39 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/redpwn-2020/</guid>
            <description>ropes 128pts Description: It&#39;s not just a string, it&#39;s a rope! File: ropes Author: NotDeGhost on this challenge we were given Mach-O binary file ropes.
❯ file ropes ropes: Mach-O 64-bit x86_64 executable, flags:&amp;lt;NOUNDEFS|DYLDLINK|TWOLEVEL|PIE&amp;gt; to solve the first challenge is not too difficult, we can use the strings command to find interesting strings that we might be able to see the flag.
❯ strings ropes ... /usr/lib/libSystem.B.dylib Give me a magic number: First part is: flag{r0pes_ar3_ Second part is: just_l0ng_str1ngs} @dyld_stub_binder @_printf .</description>
            <content type="html"><![CDATA[<hr>
<h3 id="ropes-128pts">ropes 128pts</h3>
<pre><code>Description:
It's not just a string, it's a rope!

File:
ropes

Author: 
NotDeGhost
</code></pre><p>on this challenge we were given Mach-O binary file <a href="https://github.com/insomn14/CTFtime2020/blob/master/redpwnCTF/rev/ropes"><em>ropes</em></a>.</p>
<pre><code>❯ file ropes 
ropes: Mach-O 64-bit x86_64 executable, flags:&lt;NOUNDEFS|DYLDLINK|TWOLEVEL|PIE&gt;
</code></pre><p>to solve the first challenge is not too difficult, we can use the <code>strings</code> command to find interesting strings that we might be able to see the flag.</p>
<pre><code>❯ strings ropes
...
/usr/lib/libSystem.B.dylib
Give me a magic number: 
First part is: flag{r0pes_ar3_
Second part is: just_l0ng_str1ngs}
@dyld_stub_binder
@_printf
...
</code></pre><p>FLAG : <code>flag{r0pes_ar3_just_l0ng_str1ngs}</code></p>
<hr>
<h3 id="bubbly-395pts">bubbly 395pts</h3>
<pre><code>Description:
It never ends

nc 2020.redpwnc.tf 31039

File:
bubbly

Author: 
dns
</code></pre><p>At the challenge we are given binary files <a href="https://github.com/insomn14/CTFtime2020/tree/master/redpwnCTF/rev/bubbly"><em>bubbly</em></a></p>
<pre><code>❯ file bubbly 
bubbly: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=edb56d2d9355bcee01909f171d8a272a3e82d053, with debug_info, not stripped
</code></pre><p>The following is a pseudocode snippet from the <em>bubbly</em> program, as we see there are variable array <code>nums</code> and there are repeats, which are intended to move each element position to array <code>nums</code> and there is a <code>check()</code> function, this function is useful for checking each element on Array <code>nums</code> whether the element in the array <code>nums</code> is sorted, if the element array <code>nums</code> is already passed the <code>check ()</code> function returns the value <code>0 == True</code> if it does not return the value <code>1 == False</code>.</p>
<pre><code>...
.data:0000000000004060 nums            dd 1, 10, 3, 2, 5, 9, 8, 7, 4, 6
...
  puts(&quot;I hate my data structures class! Why can't I just sort by hand?&quot;);
  for ( pass = 0; ; pass = check() )
  {
    unused = __isoc99_scanf(&quot;%d&quot;, &amp;i);
    if ( i &gt; 8 )
      break;
    nums[i] ^= nums[i + 1];
    nums[i + 1] ^= nums[i];
    nums[i] ^= nums[i + 1];
  }
 ...
BOOL8 __fastcall check()
{
  uint32_t i; // [rsp+0h] [rbp-8h]
  bool pass; // [rsp+7h] [rbp-1h]

  pass = 1;
  for ( i = 0; i &lt;= 8; ++i )
  {
    if ( nums[i] &gt; nums[i + 1] )
      return 0;
  }
  return pass;
}
</code></pre><p>To solve this challenge I use <a href="https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/visualize/"><em>hackerearth</em></a> to make it easier to solve the challenge. After getting a value to sort the array of nums, enter a value greater than 8 to exit the loop.</p>
<pre><code>❯ ./connect.sh        
I hate my data structures class! Why can't I just sort by hand?
1
2
3
4
5
6
7
8
1
4
5
6
7
4
5
6
4
5
3
9
Well done!
flag{4ft3r_y0u_put_u54c0_0n_y0ur_c011ege_4pp5_y0u_5t1ll_h4ve_t0_d0_th15_57uff}
</code></pre><p>FLAG : <code>flag{4ft3r_y0u_put_u54c0_0n_y0ur_c011ege_4pp5_y0u_5t1ll_h4ve_t0_d0_th15_57uff}</code></p>
<hr>
<h3 id="smart-solver-475pts">SMarT-solver 475pts</h3>
<pre><code>Description:
Find the correct flag. :)

NOTE: All letters in the flag are lowercase

File:
SMarT-solver

Author: 
MrSlick
</code></pre><p>In the following challenges we are given a binary file <a href="https://github.com/insomn14/CTFtime2020/tree/master/redpwnCTF/rev/SMarT-solver"><em>SMarT-solver</em></a>.</p>
<pre><code>❯ file SMarT-solver
SMarT-solver: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=27bf1ae8e39bad973a605ab44e3b36a64e2134c6, not stripped
</code></pre><p>If you are familiar with the challenge of reversing, maybe we will get to know what we should do next. If you don&rsquo;t understand, let me explain briefly. If we pay attention i think they wants to try saying &ldquo;SMT-solver&rdquo;, so we need to prepare our z3 already installed to help us solve this challenge and we are also told that All letters in the flag are lowercase. Let&rsquo;s look deeper to understand how the binary works.</p>
<pre><code>...
     90d:       48 8d 85 e0 fe ff ff    lea    rax,[rbp-0x120]	&lt;-----------+
     914:       48 89 c7                mov    rdi,rax                      |
     917:       e8 c4 fd ff ff          call   6e0 &lt;strlen@plt&gt;             |
     91c:       48 83 f8 48             cmp    rax,0x48     &lt;---------------+---&gt; compare input length with 0x48 / 72
     920:       0f 86 9c b0 01 00       jbe    1b9c2 &lt;main+0x1b168&gt;         
     926:       0f b6 95 e0 fe ff ff    movzx  edx,BYTE PTR [rbp-0x120] &lt;---+
     92d:       0f b6 85 e1 fe ff ff    movzx  eax,BYTE PTR [rbp-0x11f] &lt;---| 
     934:       38 c2                   cmp    dl,al        &lt;---------------|
     936:       0f 83 8c b0 01 00       jae    1b9c8 &lt;main+0x1b16e&gt;         |
     93c:       0f b6 95 e0 fe ff ff    movzx  edx,BYTE PTR [rbp-0x120] &lt;---|
     943:       0f b6 85 e2 fe ff ff    movzx  eax,BYTE PTR [rbp-0x11e] &lt;---|
     94a:       38 c2                   cmp    dl,al        &lt;---------------+---&gt; compare each character in our input
     94c:       0f 86 7c b0 01 00       jbe    1b9ce &lt;main+0x1b174&gt;         |
     952:       0f b6 95 e0 fe ff ff    movzx  edx,BYTE PTR [rbp-0x120] &lt;---|
     959:       0f b6 85 e3 fe ff ff    movzx  eax,BYTE PTR [rbp-0x11d] &lt;---|
     960:       38 c2                   cmp    dl,al        &lt;---------------|
     962:       0f 83 6c b0 01 00       jae    1b9d4 &lt;main+0x1b17a&gt;         |
...
</code></pre><p>After a few minutes doing static analysis it can be concluded that the flag length is 72 characters and that each character is compared to each other. The next step is to take the assembly code and clean it to make the code look clearer. After that, let&rsquo;s create a script to complete this challenge. Visit my <a href="https://github.com/insomn14/CTFtime2020/tree/master/redpwnCTF/rev/SMarT-solver"><em>github</em></a> to see my solver code</p>
<pre><code>❯ python solver.py
flag{thequickbrownfoxjumpedoverthelazydogandlearnedhowtoautomateanalysis}

❯ python solver.py | ./SMarT-solver
Welcome to SMarT solver!
The #1 solution for your flag checking needs.

Enter a flag: 
Correct input!
</code></pre><p>FLAG : <code>flag{thequickbrownfoxjumpedoverthelazydogandlearnedhowtoautomateanalysis}</code></p>
<hr>
<h3 id="a-round-mechanism-495pts">a-round-mechanism 495pts</h3>
<pre><code>Description:
I found a respectable mainframe, can you help me get in? Flag is in flag.txt

nc 2020.redpwnc.tf 31359

File:
ARM

Author:
green beans
</code></pre><p>In this challenge we are given a 32-bit <a href="https://github.com/insomn14/CTFtime2020/tree/master/redpwnCTF/rev/a-round-mechanism"><em>ARM</em></a> stripped binary file</p>
<pre><code>❯ file ARM
ARM: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=714b6b1a1949f1f0d3912e7e13fef4420e2d4efa, stripped
</code></pre><p>After spending several hours doing static analysis I found a way to solve this challenge. As you can see here is a program flow where the length of the input must be 0x16 / 22 characters, the next step is that each character will be xor with 0x12 / 18.</p>
<pre><code>...
.data:00086064                 LDR     R2, =loc_86008 &lt;-------- Our input is stored at loc_86008
.data:00086068                 MOV     R0, #0     &lt;---------+
.data:0008606C                 MOV     R1, #0x16  &lt;---------+-- Prepare looping 22 times
.data:00086070 loc_86070                               ; CODE XREF: .data:00086090↓j
.data:00086070                 LDRB    R3, [R2,R0] &lt;-----------+
.data:00086074                 MOV     R4, R3                  |
.data:00086078                 EOR     R4, R4, #0x12 &lt;---------+-- Each character will be xor with 18
.data:0008607C                 STRB    R4, [R2,R0]
.data:00086080                 CMP     R3, #0xA
.data:00086084                 BLEQ    loc_163BC
.data:00086088                 ADD     R0, R0, #1
.data:0008608C                 CMP     R0, R1   &lt;--------+
.data:00086090                 BLE     loc_86070  &lt;------+-- Return to loc_86070 if R0 is still smaller than R1 
...
</code></pre><p>Then the sub_860EC function will be called and the value 1 and our input as parameters. The essence of the sub_860EC function every two characters from our input will be shifted left and shifted right once. After that the two results will be added up then the result is shifted right 7 times and subtracted by 1. This will be repeated 22 times.</p>
<pre><code>...
.data:00086094                 LDR     R0, =loc_86008 &lt;-----+
.data:00086098                 MOV     R1, #1               |
.data:0008609C                 BL      sub_860EC &lt;----------+-- sub_860EC(R0, R1)
...
.data:000860EC sub_860EC                               ; CODE XREF: .data:0008609C↑p
.data:000860EC                                         ; sub_860EC+70↓p
.data:000860EC                 PUSH    {LR}
.data:000860F0                 PUSH    {R12}
.data:000860F4                 PUSH    {R0}
.data:000860F8                 PUSH    {R1}
.data:000860FC                 SUB     SP, SP, #8
.data:00086100                 MOV     R12, SP
.data:00086104                 ADDLT   R1, R1, #1
.data:00086108                 CMP     R1, #0x16 &lt;-----+
.data:0008610C                 BNE     loc_86118 &lt;-----+-- Jump to loc_86118 if R1 not Equal 0x16 / 22
.data:00086110                 MOV     R0, #1
.data:00086114                 B       loc_86160 &lt;----- exit from function sub_860EC
.data:00086118 ; ---------------------------------------------------------------------------
.data:00086118
.data:00086118 loc_86118                               ; CODE XREF: sub_860EC+20↑j
.data:00086118                 MOV     R6, R0  &lt;--------------- Our input is moved to R6 from R0 in parameter 1
.data:0008611C                 MOV     R8, R1  &lt;----------+ 
.data:00086120                 LDRB    R9, [R6,R8] &lt;------+ R9 = R6[R8] Take the next character from our input
.data:00086124                 MOV     R10, R9
.data:00086128                 SUB     R5, R8, #1 &lt;--------+ R8 is subtracted 1 to retrieve the previous character
.data:0008612C                 LDRB    R12, [R6,R5] &lt;------+ R12 = R6[R5]
.data:00086130                 MOV     R5, R12
.data:00086134                 MOV     R5, R5,LSR#1  &lt;------+ LSR (Logical Shift Right) R5 = (R5 &gt;&gt; 1)
.data:00086138                 MOV     R10, R10,LSL#1 &lt;-----+ LSL (Logical Shift Left) R10 = (R10 &lt;&lt; 1)
.data:0008613C                 ADD     R7, R5, R10 &lt;--------+ R7 = (R5 + R10)
.data:00086140                 MOV     R10, R7
.data:00086144                 MOV     R7, R7,LSR#7  &lt;------+ R7 = (R7 &gt;&gt; 7)
.data:00086148                 MOV     R10, R10,LSR R7      |
.data:0008614C                 SUB     R10, R10, #1 &lt;-------+ R10 = (R7 &gt;&gt; (R10 &gt;&gt; R7)) - 1 
.data:00086150                 STRB    R10, [R6,R8] &lt;----------- R6[R8] = R10
.data:00086154                 LDR     R0, =loc_86008 &lt;-----+
.data:00086158                 MOV     R1, R8               |
.data:0008615C                 BL      sub_860EC &lt;----------+-- sub_860EC(R0, R1)
.data:00086160
.data:00086160 loc_86160                               ; CODE XREF: sub_860EC+28↑j
.data:00086160                 ADD     SP, SP, #8
.data:00086164                 POP     {R1}
.data:00086168                 POP     {R0}
.data:0008616C                 POP     {R12}
.data:00086170                 POP     {PC}
...
</code></pre><p>Last but not least  the results of our input will be compared with <code>te@B}efFk~{^Ixv@}y\\BC4</code> Because this program is &lsquo;little enddian&rsquo; it should look like this <code>4CB\\y}@vxI^{~kFfe}B@et</code>.</p>
<pre><code>...
.data:000860A0                 LDR     R2, =loc_86008
.data:000860A4                 LDR     R3, =aTeBEffkIxvYBc4 ; &quot;te@B}efFk~{^Ixv@}y\\BC4&quot;
...
</code></pre><p>The following is the output of my solver. Visit my <a href="https://github.com/insomn14/CTFtime2020/tree/master/redpwnCTF/rev/a-round-mechanism"><em>github</em></a> to see my solver code.</p>
<pre><code>❯ python3 solver.py
Know 1st char : 4
Restore 2nd char: C
- possibility : 7
- possibility : {
- possibility : |
-----------------------------------
Result - 7 : 473Mc!cg\vMeaMtVMeg1V\
Compare key : True
Key found : &amp;%!_q3quNd_ws_fD_wu#DN
-----------------------------------
Result - { : 4{3Mc!cg\vMeaMtVMeg1V\
Compare key : True
Key found : &amp;i!_q3quNd_ws_fD_wu#DN
-----------------------------------
Result - | : 4|3Mc!cg\vMeaMtVMeg1V\
Compare key : True
Key found : &amp;n!_q3quNd_ws_fD_wu#DN
</code></pre><p>I tried all three keys which I found all worked well.</p>
<pre><code>❯ ./connect.sh
I hear you've come to bargain for flags
 I'm a reasonable machine, if you guess the password I can give you a flag
&amp;%!_q3quNd_ws_fD_wu#DN
Nice, you did it! Have your flag:   cat flag.txt
flag{4_r3gu14R_m0N5tr051Ty}

❯ ./connect.sh
I hear you've come to bargain for flags
 I'm a reasonable machine, if you guess the password I can give you a flag
&amp;i!_q3quNd_ws_fD_wu#DN
Nice, you did it! Have your flag:   cat flag.txt
flag{4_r3gu14R_m0N5tr051Ty}

❯ ./connect.sh
I hear you've come to bargain for flags
 I'm a reasonable machine, if you guess the password I can give you a flag
&amp;n!_q3quNd_ws_fD_wu#DN
Nice, you did it! Have your flag:   cat flag.txt
flag{4_r3gu14R_m0N5tr051Ty}
</code></pre><p>FLAG : <code>flag{4_r3gu14R_m0N5tr051Ty}</code></p>
]]></content>
        </item>
        
        <item>
            <title>NoobCTF0x1 | Crypto *Writeups*</title>
            <link>https://insomn14.github.io/posts/noobctf0x1-crypto/</link>
            <pubDate>Tue, 09 Jun 2020 12:16:12 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/noobctf0x1-crypto/</guid>
            <description>Gross 120pts Cipher: OQWKWPUVMYTIUSSTHHPI Keep this: 12345 , will help you. Flag format: noob{FLAG} Author: D3v1LaL In CTF competitions the title of the challenge sometimes can be a clue. For example in this challenge, I thought that the word &amp;lsquo;Gross&amp;rsquo; was a play on words from &amp;lsquo;Grons&amp;rsquo; so I concluded it might be &amp;lsquo;Gronsfeld Cipher&amp;rsquo;. The conclusion I got after reading the pycipher documentation.
&amp;gt;&amp;gt;&amp;gt; import pycipher &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; msg = pycipher.</description>
            <content type="html"><![CDATA[<hr>
<h2 id="gross-120pts">Gross 120pts</h2>
<pre><code>Cipher: OQWKWPUVMYTIUSSTHHPI

Keep this: 12345 , will help you. Flag format: noob{FLAG}

Author: D3v1LaL
</code></pre><p>In CTF competitions the title of the challenge sometimes can be a clue. For example in this challenge, I thought that the word &lsquo;Gross&rsquo; was a play on words from &lsquo;Grons&rsquo; so I concluded it might be &lsquo;Gronsfeld Cipher&rsquo;. The conclusion I got after reading the <a href="https://pycipher.readthedocs.io/en/master/#id16">pycipher</a> documentation.</p>
<pre><code>&gt;&gt;&gt; import pycipher
&gt;&gt;&gt;
&gt;&gt;&gt; msg = pycipher.Gronsfeld([1,2,3,4,5]).decipher('OQWKWPUVMYTIUSSTHHPI')
&gt;&gt;&gt; msg
'NOTGROSSITSGRONSFELD'
</code></pre><p>FLAG : <code>noob{NOTGROSSITSGRONSFELD}</code></p>
<hr>
<h2 id="aar_ess_ae-20-200pts">Aar_Ess_Ae 2.0 200pts</h2>
<pre><code>Optimus Prime Loves The Title Of This Song: https://www.youtube.com/watch?v=wyx6JDQCslE

Author: D3v1LaL
</code></pre><p>We were given an aresae2.txt file that contained</p>
<pre><code>n: 1209143407476550975641959824312993703149920344437422193042293131572745298662696284279928622412441255652391493241414170537319784298367821654726781089600780498369402167443363862621886943970468819656731959468058528787895569936536904387979815183897568006750131879851263753496120098205966442010445601534305483783759226510120860633770814540166419495817666312474484061885435295870436055727722073738662516644186716532891328742452198364825809508602208516407566578212780807
e: 65537
c: 479864533376761605695501447173868480555428955121197237667644363164782871896916177280454277070395501072881821206028710238061428135752902868021510351013602427444705377461961807606024656743172785917677779391848195684330103645049456693618142623342949445393135435605296850775153054696353591431012573391751673267024658145416936335505273041995697052197680305689264142043959382559774510439925577487721780439642813074520685265074584526487330950173513520723457640547997316 
</code></pre><p>I use <a href="https://github.com/Ganapati/RsaCtfTool">RsaCtfTool</a> to help me get a private key. After that we can create simple script to decrypt value of c</p>
<!-- raw HTML omitted -->
<pre><code>from Crypto.Util.number import long_to_bytes
from Crypto.PublicKey import RSA

c = 479864533376761605695501447173868480555428955121197237667644363164782871896916177280454277070395501072881821206028710238061428135752902868021510351013602427444705377461961807606024656743172785917677779391848195684330103645049456693618142623342949445393135435605296850775153054696353591431012573391751673267024658145416936335505273041995697052197680305689264142043959382559774510439925577487721780439642813074520685265074584526487330950173513520723457640547997316
f = open('keypair.pem', 'r').read()
key = RSA.importKey(f)
m = long_to_bytes(pow(c, key.d, key.n))
with open('flag.txt', 'w') as w:
        w.write(str(m))
        w.close()
print(m)
</code></pre>
<!-- raw HTML omitted -->
<p>FLAG : <code>noob{Primes_Can_B3_Saxy_T00}</code></p>
<hr>
<h2 id="crackmeh-250pts">CrackMeh 250pts</h2>
<pre><code>3lli0t found a diary from Evil Corp. He have to get into the system, but can't as he have a hash of a password and no plaintext. Help him to get into system.

flag format: noob{plaintext}

hash: 4ee805f9397a1d584ef9be9d2a4f8f20

Author: D3v1LaL
</code></pre><p>We were given an diary.txt file that contained</p>
<pre><code>_________________________
|                       |
|                       |
|                       |
|         Alice         |
|        January        |
|         1994          |
|         USA           |
|          25           |
|       Security        |
|                       |
|                       |
|_______________________|
</code></pre><p>To solve this challenge, we can use diary.txt as information, maybe the hash contains some of these words.</p>
<!-- raw HTML omitted -->
<pre><code>from itertools import permutations
import hashlib

def checked(inc, data):
    for data in permutations(data, inc):
        temp = bytes(''.join((data)), 'utf-8')
        m = hashlib.md5()
        m.update(temp)
        result = m.hexdigest()
        if result == hashed:
            print(f'FOUND : {result} -&gt; {temp}')
            return True
    return False

hashed = '4ee805f9397a1d584ef9be9d2a4f8f20'
data = ['Alice', 'January', '1994', 'USA', '25', 'Security']
for cnt in range(1, len(data)+1):
    if checked(cnt, data):
        exit()
</code></pre>
<!-- raw HTML omitted -->
<p>FLAG : <code>noob{AliceSecurity1994}</code></p>
<hr>
<h2 id="frequency-250pts">Frequency 250pts</h2>
<pre><code>Elliot captured something, while noob called his friend

Flag format: noob{FLAG}

Author: D3v1LaL
</code></pre><p>in this challenge we were given Cipher.txt file</p>
<pre><code>1209-770 1209-770 1477-697 1477-697 1336-770 1336-770 1336-770 1336-770 1336-770 1336-770 1477-770 1477-770 1477-770 1477-697 1336-852 1477-770 1477-697 1477-697 1477-697
</code></pre><p>As I mentioned earlier, the title of the challenge is usually a hint. The following challenges are <a href="https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling">DTMF</a> keypad frequencies.</p>
<p>After decoding the signal we will get a number <code>44335555566386333</code>,
replace the numbers you have obtained with the letter at each press of the T9 keyboard.
<code>HELLODTMF</code></p>
<p>FLAG : <code>noob{HELLODTMF}</code></p>
]]></content>
        </item>
        
        <item>
            <title>NoobCTF0x1 | Forensics *Writeups*</title>
            <link>https://insomn14.github.io/posts/noobctf0x1-forensics/</link>
            <pubDate>Tue, 09 Jun 2020 09:16:12 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/noobctf0x1-forensics/</guid>
            <description>Can You Hear Me !!! 50pts While performing Man in the Middle attack, I got a secret message from a scientist which can save the world from COVID-19. But unfortunatly I am not able to hear that. I believe that someone with good knowledge of some tools can get the secret message. Note: Online tools also works. Link: https://mega.nz/file/xdxHiQbb#vK91LAP9JjVKxQnMp6e_J1x7-IOIiqbST-htEAmdQWo Replace spaces with _ At this challenge we were given the audio file Challenge.</description>
            <content type="html"><![CDATA[<hr>
<h2 id="can-you-hear-me--50pts">Can You Hear Me !!! 50pts</h2>
<pre><code>While performing Man in the Middle attack, I got a secret message from a scientist which can save the world from COVID-19. But unfortunatly I am not able to hear that. I believe that someone with good knowledge of some tools can get the secret message.

Note: Online tools also works.

Link: https://mega.nz/file/xdxHiQbb#vK91LAP9JjVKxQnMp6e_J1x7-IOIiqbST-htEAmdQWo

Replace spaces with _
</code></pre><p>At this challenge we were given the audio file Challenge.mp3, the sound on this audio is very small. So you have to increase the volume to hear the sound clearly, and you will get the link. <a href="https://www.shortto.com/noobarmy">https://www.shortto.com/noobarmy</a></p>
<p>After that you will be directed to download the audio.wav file. The file contains the Morse code sound. now we can decode the message <a href="https://morsecode.world/international/decoder/audio-decoder-adaptive.html">link</a></p>
<p>FLAG : <code>noob{I_H4V3_M4D3_C0R0NA_VACC1N3}</code></p>
<hr>
<h2 id="its-easy-50pts">It&rsquo;s easy 50pts</h2>
<pre><code>It's just an image

Link: https://github.com/AdityaSec/NoobCTF-0x1/tree/master/Forensics/It's easy

Author: Cryptonic007
</code></pre><p>on these challenge we were given image file iameasy.jpg but the file was corrupted. after doing analyze the signatures a.k.a Magic Bytes is different according to <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">List of file signatures</a></p>
<p>Before :</p>
<pre><code>$ xxd iameasy.jpg | head -n2
00000000: 0510 1902 0010 4a46 4946 0001 0100 0048  ......JFIF.....H
00000010: 0048 0000 fffe 003b 4352 4541 544f 523a  .H.....;CREATOR:
</code></pre><p>After :</p>
<pre><code>$ xxd mod_iameasy.jpg | head -n2
00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0048  ......JFIF.....H
00000010: 0048 0000 fffe 003b 4352 4541 544f 523a  .H.....;CREATOR:
</code></pre><p>FLAG : <code>noob{1_t0ld_y0u_1ts_34sy}</code></p>
<hr>
<h2 id="fine-the-tone-250pts">Fine the tone 250pts</h2>
<pre><code>James bond tried to find the tone. But, he tired now. Can you help me?

NOTE: Flag format noob{ALLCAPITAL}

Author: Cryptonic007
</code></pre><p>In this challenge, it is almost similar to the &lsquo;Frequency&rsquo; crypto challenge. but this time we have to analyze the frequency, to do that we can use Audacity, change it to spectrogram. <a href="https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling">link</a></p>
<p><img src="/img/Screenshot/NoobCTF0x1/Screenshot.png" alt="image" title="Screenshot"></p>
<p>From there we can start analyzing each frequency. after you get a number, replace it with the letter at each T9 keyboard emphasis.</p>
<p>FLAG : <code>noob{YOUGOTTHETONE}</code></p>
]]></content>
        </item>
        
        <item>
            <title>TAMUctf 2020 | RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/tamuctf-2020/</link>
            <pubDate>Mon, 30 Mar 2020 06:16:12 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/tamuctf-2020/</guid>
            <description>RUSTY_AT_REVERSING Description: A nice little reversing challenge for those who are a little rusty! File: librusty_at_reversing.so In this challenge we are given the file librusty_at_reversing.so file, as know as Shared Object file.
➜ RUSTY_AT_REVERSING file librusty_at_reversing.so librusty_at_reversing.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=c4b7c1decfcaa244827e5289a0f88888665caa25, stripped Let&amp;rsquo;s just decompile the file using radare2.
[0x00001040]&amp;gt; afl 0x00001040 4 41 -&amp;gt; 34 entry0 0x00001220 13 292 sym.decrypt 0x00001100 13 288 sym.</description>
            <content type="html"><![CDATA[<hr>
<h3 id="rusty_at_reversing">RUSTY_AT_REVERSING</h3>
<pre><code>Description:
A nice little reversing challenge for those who are a little rusty!

File:
librusty_at_reversing.so
</code></pre><p>In this challenge we are given the file <a href="https://github.com/insomn14/CTFtime2020/tree/master/TAMUctf_2020/Reversing/RUSTY_AT_REVERSING"><em>librusty_at_reversing.so</em></a> file, as know as <a href="https://superuser.com/questions/71404/what-is-an-so-file"><em>Shared Object</em></a>  file.</p>
<pre><code>➜  RUSTY_AT_REVERSING file librusty_at_reversing.so 
librusty_at_reversing.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=c4b7c1decfcaa244827e5289a0f88888665caa25, stripped
</code></pre><p>Let&rsquo;s just decompile the file using radare2.</p>
<pre><code>[0x00001040]&gt; afl

0x00001040    4 41   -&gt; 34   entry0
0x00001220   13 292          sym.decrypt
0x00001100   13 288          sym.encrypt
0x00001350    1 219          sym.get_flag
0x000010f0    5 137  -&gt; 60   entry.init0
0x000010b0    5 57   -&gt; 54   entry.fini0
0x000018d0    6 79           fcn.000018d0
</code></pre><p>As we can see, there are two very interesting functions namely <code>sym.get_flag</code> and <code>sym.decrypt</code>.</p>
<pre><code>[0x000018d0]&gt; pdg@sym.get_flag

int64_t sym.get_flag(int64_t arg1)
{
 
 	...
 	...
    
    uStack28 = 0x83;
    uStack27 = 0xea;
    uStack26 = 0x8d;
    uStack25 = 0xe8;
    uStack24 = 0x85;
    uStack23 = 0xfe;
    uStack22 = 0x93;
    uStack21 = 0xe1;
    uStack20 = 0xbe;
    uStack19 = 0xcd;
    uStack18 = 0xb9;
    uStack17 = 0xd8;
    uStack16 = 0xaa;
    uStack15 = 0xc1;
    uStack14 = 0x9e;
    uStack13 = 0xf7;
    uStack12 = 0xa8;
    uStack11 = 0xce;
    uStack10 = 0xab;
    uStack9 = 0xce;
    uStack8 = 0xa2;
    uStack7 = 0xfd;
    uStack6 = 0x8f;
    uStack5 = 0xfa;
    uStack4 = 0xf984fd89;
    (*_reloc.decrypt)(&amp;uStack28, in_RSI, in_RDX, &amp;uStack28);
    *(uint64_t *)arg1 =
         CONCAT17(uStack21, 
                  CONCAT16(uStack22, 
                           CONCAT15(uStack23, 
                                    CONCAT14(uStack24, 
                                             CONCAT13(uStack25, CONCAT12(uStack26, CONCAT11(uStack27, uStack28)))))));
    *(uint64_t *)(arg1 + 8) =
         CONCAT17(uStack13, 
                  CONCAT16(uStack14, 
                           CONCAT15(uStack15, 
                                    CONCAT14(uStack16, 
                                             CONCAT13(uStack17, CONCAT12(uStack18, CONCAT11(uStack19, uStack20)))))));
    *(uint64_t *)(arg1 + 0x10) =
         CONCAT17(uStack5, CONCAT16(uStack6, CONCAT15(uStack7, CONCAT14(uStack8, CONCAT13(uStack9, CONCAT12(uStack10, 
                                                                                                            CONCAT11(
                                                            uStack11, uStack12)))))));
    *(undefined4 *)(arg1 + 0x18) = uStack4;
    return arg1;
}
</code></pre><p>In the <code>sym.get_flag</code> function there is a variable <code>uStack4</code> until <code>uStack28</code> we can assume it is an array, then var <code>uStack</code> is sent as a parameter to the <code>sym.decrypt</code> function.</p>
<pre><code>[0x000018d0]&gt; pdg@sym.decrypt

void sym.decrypt(int64_t arg1)
{
    code cVar1;
    undefined uStack9;
    uint64_t uStack8;
    
    uStack9 = segment.LOAD2;
    uStack8 = 0;
    do {
      	
      	...
      	...
      	
        *(uint8_t *)(arg1 + uStack8) = (uint8_t)uStack9 ^ *(uint8_t *)(arg1 + uStack8);
        uStack8 = uStack8 + 1;
        uStack9 = cVar1;
    } while (uStack8 != 0x1c);
    return;
}

[0x00001040]&gt; px 0xf @ segment.LOAD2
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00002000  e473 7263 2f6c 6962 2e72 7300 2ff8 ff    .src/lib.rs./.. 
</code></pre><p>As we see there is a loop where every value in <code>arg1</code> will be xor with <code>uStack9</code> == <em>0xe4 &ndash;&gt; 228</em>.</p>
<p>Now let&rsquo;s create a simple code to solve it.</p>
<pre><code>def decrypt(a1):
    v3 = 228
    for i in range(len(a1)):
        v2 = v3
        v3 = a1[i]
        a1[i] = chr(a1[i]^v2)

    return a1

flag = [0x83, 0xea, 0x8d, 0xe8, 0x85, 0xfe, 0x93, 0xe1, 0xbe, 0xcd, 0xb9, 0xd8, 0xaa, 0xc1, 0x9e, 0xf7, 0xa8, 0xce, 0xab, 0xce, 0xa2, 0xfd, 0x8f, 0xfa, 0x89, 0xfd, 0x84, 0xf9]

print(''.join(decrypt(flag)))
</code></pre><p>Let&rsquo;s run our script.</p>
<pre><code>➜  RUSTY_AT_REVERSING python solve.py 
gigem{mr_stark_i_feel_rusty}
</code></pre><p>FLAG: <code>gigem{mr_stark_i_feel_rusty}</code></p>
<hr>
<h3 id="vault">VAULT</h3>
<pre><code>Description:


File:
vault

</code></pre><p>In the following challenge we are given a <a href="https://github.com/insomn14/CTFtime2020/tree/master/TAMUctf_2020/Reversing/Vault"><em>vault</em></a> binary file.</p>
<pre><code>➜  Vault file vault 
vault: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9ff9d23fe640e7aa227f5a4a45123753c1f22298, for GNU/Linux 3.2.0, not stripped
</code></pre><p>As usual, let&rsquo;s look at the pseudocode using my favorite tool.</p>
<pre><code>[0x000010a0]&gt; pdg@main

undefined8 main(void)
{
    int32_t iVar1;
    undefined8 *arg1;
    undefined8 uVar2;
    char *s2;
    char *s1;
    
    arg1 = (undefined8 *)sym.imp.malloc(0x1a);
    *arg1 = 0x7e394c2f38323434;
    arg1[1] = 0x54834c1f7b783a78;
    arg1[2] = 0x2f72857884842928;
    *(undefined2 *)(arg1 + 3) = 0x7667;
    *(undefined *)((int64_t)arg1 + 0x1a) = 0;
    sym.deobfuscate((char *)arg1);
    uVar2 = sym.imp.malloc(0x1b);
    sym.imp.printf(0x2019, &quot;Enter password: &quot;);
    sym.imp.fgets(uVar2, 0x1b, _reloc.stdin);
    iVar1 = sym.imp.strcmp(arg1, uVar2, uVar2);
    if (iVar1 == 0) {
        sym.imp.puts(&quot;Correct!  That\'s the password!&quot;);
    } else {
        sym.imp.puts(&quot;Sorry, that isn\'t the right password.&quot;);
    }
    return 0;
}
</code></pre><p>As we can see the pointer variable <code>arg1</code> allocates 0x1a -&gt; 26 bytes, in the next line after <code>arg1</code> stores the hex value and there is a <code>sym.deobfuscate</code> function call. After that the value of <code>arg1</code> will be compared with our input.</p>
<p>The easiest way to complete this challenge without needing to know the task of the <code>sym.deobfuscate</code> function is to place breakpoints after calling the <code>sym.deobfuscate</code> function. I use gdb to do debugging.</p>
<pre><code>gdb-peda$ start
   ...
   ...

gdb-peda$ disassemble 
   ...
   0x55555555531d &lt;main+84&gt;:    call   0x555555555185 &lt;deobfuscate&gt;
   0x555555555322 &lt;main+89&gt;:    mov    edi,0x1b
   ...

gdb-peda$ b*main+89
Breakpoint 3 at 0x555555555322

gdb-peda$ c
Continuing.
[----------------------------------registers-----------------------------------]
RAX: 0x5555555592a0 (&quot;gigem{p455w0rd_1n_m3m0ry1}&quot;)
RBX: 0x0 
RCX: 0x69 ('i')
RDX: 0x67 ('g')
RSI: 0x67 ('g')
RDI: 0x5555555592a0 (&quot;gigem{p455w0rd_1n_m3m0ry1}&quot;)
RBP: 0x7fffffffdad0 --&gt; 0x5555555553a0 (&lt;__libc_csu_init&gt;:      push   r15)
RSP: 0x7fffffffdac0 --&gt; 0x7fffffffdbb0 --&gt; 0x1 
RIP: 0x555555555322 (&lt;main+89&gt;: mov    edi,0x1b)
R8 : 0xf8ff 
R9 : 0x7ffff7e70fc0 (&lt;__wcpcpy&gt;:        endbr64)
R10: 0xfffffffffffff49f 
R11: 0x7ffff7e65d60 (&lt;__strlen_sse2&gt;:   endbr64)
R12: 0x5555555550a0 (&lt;_start&gt;:  xor    ebp,ebp)
R13: 0x7fffffffdbb0 --&gt; 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x555555555316 &lt;main+77&gt;:    mov    rax,QWORD PTR [rbp-0x8]
   0x55555555531a &lt;main+81&gt;:    mov    rdi,rax
   0x55555555531d &lt;main+84&gt;:    call   0x555555555185 &lt;deobfuscate&gt;
=&gt; 0x555555555322 &lt;main+89&gt;:    mov    edi,0x1b
   0x555555555327 &lt;main+94&gt;:    call   0x555555555080 &lt;malloc@plt&gt;
   0x55555555532c &lt;main+99&gt;:    mov    QWORD PTR [rbp-0x10],rax
   0x555555555330 &lt;main+103&gt;:   lea    rsi,[rip+0xcd1]        # 0x555555556008
   0x555555555337 &lt;main+110&gt;:   lea    rdi,[rip+0xcdb]        # 0x555555556019
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdac0 --&gt; 0x7fffffffdbb0 --&gt; 0x1 
0008| 0x7fffffffdac8 --&gt; 0x5555555592a0 (&quot;gigem{p455w0rd_1n_m3m0ry1}&quot;)
0016| 0x7fffffffdad0 --&gt; 0x5555555553a0 (&lt;__libc_csu_init&gt;:     push   r15)
0024| 0x7fffffffdad8 --&gt; 0x7ffff7dd81e3 (&lt;__libc_start_main+243&gt;:       mov    edi,eax)
0032| 0x7fffffffdae0 --&gt; 0x7ffff7f98598 --&gt; 0x7ffff7dd7ac0 (&lt;init_cacheinfo&gt;:   endbr64)
0040| 0x7fffffffdae8 --&gt; 0x7fffffffdbb8 --&gt; 0x7fffffffdf8c (&quot;/home/insomnia/CTF101/CTFtime2020/12.TAMUctf
0048| 0x7fffffffdaf0 --&gt; 0x1f7f66e88 
0056| 0x7fffffffdaf8 --&gt; 0x5555555552c9 (&lt;main&gt;:        push   rbp)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 3, 0x0000555555555322 in main ()
gdb-peda$ 
</code></pre><p>Clearly visible on the column stack and at the $ RAX register, the <code>deobfucate</code> function returns the <code>arg1</code> value as char, and the password is our flag.</p>
<pre><code>➜  Vault ./vault 
Enter password: gigem{p455w0rd_1n_m3m0ry1}
Correct!  That's the password!
</code></pre><p>FLAG: <code>gigem{p455w0rd_1n_m3m0ry1}</code></p>
<hr>
<h3 id="angrmanagement">ANGRMANAGEMENT</h3>
<pre><code>Description:


File:
angrmanagement
</code></pre><p>At this time we are given the <a href="https://github.com/insomn14/CTFtime2020/tree/master/TAMUctf_2020/Reversing/ANGRMANAGEMENT"><em>angrmanagement</em></a> binary file.</p>
<pre><code>➜  ANGRMANAGEMENT file angrmanagement
angrmanagement: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=73fc1cce8d06eebb6bda739fb22cd50059cf73ba, for GNU/Linux 3.2.0, not stripped
</code></pre><p>The challenge this time is the same as the challenges in general, where we are asked to enter the correct input.</p>
<pre><code>➜  ANGRMANAGEMENT ./angrmanagement 
Enter the password:
123321123321
Incorrect.
</code></pre><p>Let&rsquo;s see disassambly from this program.</p>
<pre><code>[0x00001120]&gt; afl
...
...
0x000013cf    6 74           sym.check_4
0x0000199c    6 122          sym.check_18
0x00001fff    6 112          sym.check_31
0x00001209    1 36           sym.intify
0x000023e0    4 101          sym.__libc_csu_init
0x0000129c    6 119          sym.check_1
0x0000206f   42 874          main
0x00001ac6    6 178          sym.check_20
0x00001bf1    6 173          sym.check_22
0x00001d10    6 74           sym.check_24
0x00001dca    6 113          sym.check_26
0x00001e85    6 109          sym.check_28
0x000016a5    6 165          sym.check_11
0x00001794    6 133          sym.check_13
0x00001898    6 74           sym.check_15
...
...

[0x00001120]&gt; pdf@main
     ...
     ...
             0x000020bb      488d45d0       lea rax, [s]
│           0x000020bf      be21000000     mov esi, 0x21               ; '!' ; int size
│           0x000020c4      4889c7         mov rdi, rax                ; char *s
│           0x000020c7      e824f0ffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x000020cc      488d45d0       lea rax, [s]
     ...
     ...
│       │   0x000020e7      e866f1ffff     call sym.check_0
│       │   0x000020ec      84c0           test al, al
│      ┌──&lt; 0x000020ee      0f8453020000   je 0x2347
│      ││   0x000020f4      488d45d0       lea rax, [s]
│      ││   0x000020f8      4889c7         mov rdi, rax
│      ││   0x000020fb      e89cf1ffff     call sym.check_1
│      ││   0x00002100      84c0           test al, al
│     ┌───&lt; 0x00002102      0f843f020000   je 0x2347
     ...
     ...
           0x0000234f      8065a701       and byte [var_59h], 1
│           0x00002353      807da700       cmp byte [var_59h], 0
│       ┌─&lt; 0x00002357      7459           je 0x23b2
│       │   0x00002359      488d3db80c00.  lea rdi, str.Correct        ; 0x3018 ; &quot;Correct!&quot; ; const char *s
│       │   0x00002360      e84bedffff     call sym.imp.puts           ; int puts(const char *s)
│       │   0x00002365      488d35b50c00.  lea rsi, [0x00003021]       ; &quot;r&quot; ; const char *mode
│       │   0x0000236c      488d3db00c00.  lea rdi, str.flag.txt       ; 0x3023 ; &quot;flag.txt&quot; ; const char *filename
│       │   0x00002373      e898edffff     call sym.imp.fopen          ; file*fopen(const char *filename, const char *mode)
│       │   0x00002378      488945a8       mov qword [stream], rax
│       │   0x0000237c      48837da800     cmp qword [stream], 0
│      ┌──&lt; 0x00002381      743b           je 0x23be
│      ││   0x00002383      488b55a8       mov rdx, qword [stream]     ; FILE *stream
│      ││   0x00002387      488d45b0       lea rax, [var_50h]
│      ││   0x0000238b      be19000000     mov esi, 0x19               ; int size
│      ││   0x00002390      4889c7         mov rdi, rax                ; char *s
│      ││   0x00002393      e858edffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│      ││   0x00002398      488d45b0       lea rax, [var_50h]
│      ││   0x0000239c      4889c6         mov rsi, rax
│      ││   0x0000239f      488d3d860c00.  lea rdi, [0x0000302c]       ; &quot;%s&quot; ; const char *format
│      ││   0x000023a6      b800000000     mov eax, 0
│      ││   0x000023ab      e830edffff     call sym.imp.printf         ; int printf(const char *format)
│     ┌───&lt; 0x000023b0      eb0c           jmp 0x23be
│     │││   ; CODE XREF from main @ 0x2357
│     ││└─&gt; 0x000023b2      488d3d760c00.  lea rdi, str.Incorrect.     ; 0x302f ; &quot;Incorrect.&quot; ; const char *s
│     ││    0x000023b9      e8f2ecffff     call sym.imp.puts           ; int puts(const char *s)
│     ││    ; CODE XREFS from main @ 0x2381, 0x23b0

     ...
     ...
</code></pre><p>There are 32 <code>check</code> functions, in which each character of our input will be calculated in different check functions. If our input is correct then the program will read the <em>flag.txt</em> file.</p>
<p>If we pay close attention to the title of this challenge is a guide, angr is a tool in python that we can use to solve arithmetic operations problems that are quite complicated. This is a <a href="https://docs.angr.io/"><em>link</em></a> to learn more about angr.</p>
<p>The following is a solver I created, based on <a href="https://docs.angr.io/core-concepts/pathgroups"><em>angr Documentation.</em></a></p>
<pre><code>import angr

proj = angr.Project('./angrmanagement')

state = proj.factory.entry_state()
simgr = proj.factory.simulation_manager(state)
simgr.explore(find=lambda s: b&quot;Correct!&quot; in s.posix.dumps(1))
s = simgr.found[0]
print(s.posix.dumps(1))

result = s.posix.dumps(0)
print(result)
</code></pre><p>Run our script.</p>
<pre><code>➜  ANGRMANAGEMENT python solver.py 
b'Enter the password:\nCorrect!\n'
b'P#P7J\xb9YmT[$D5\x06[cxhtAd\xb0{(d.qxBA]j'

➜  ANGRMANAGEMENT echo 'P#P7J\xb9YmT[$D5\x06[cxhtAd\xb0{(d.qxBA]j' | ./angrmanagement
Enter the password:
Correct!
gigem{4n63r_m4n463m3n7}
</code></pre><p>FLAG: <code>gigem{4n63r_m4n463m3n7}</code></p>
<hr>
<h3 id="about_time">ABOUT_TIME</h3>
<pre><code>Description:


nc challenges.tamuctf.com 4321

File:
about_time
</code></pre><p>In this challenge we are given file  <a href="https://github.com/insomn14/CTFtime2020/tree/master/TAMUctf_2020/Reversing/ABOUT_TIME"><em>about_time</em></a> and nc service, where the flag is placed.</p>
<pre><code>➜  ABOUT_TIME file about_time 
about_time: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, stripped
</code></pre><pre><code>➜  ABOUT_TIME nc challenges.tamuctf.com 4321
2020-03-30T22:57:20WIB&gt; Encrypted password: Omt&lt;aMel5gwTao9&lt;UH6tsSb
Enter the password: test
Incorrect password! Try again.
➜  ABOUT_TIME nc challenges.tamuctf.com 4321
2020-03-30T22:58:01WIB&gt; Encrypted password: nt=bMem6gxTap:=VH7tsTbO
Enter the password: ttest
Incorrect password! Try again.
</code></pre><p>Just like the <em>RE</em> challenge before, at this time we were asked to enter a password, but the password was encrypted. If we look carefully, the encrypted password changes when the minutes of that time change. Does that mean the flags are different hhmm .. interesting 🤔️</p>
<p>Let&rsquo;s look at the pseudocode from the program, the following is the pseudocode result from IDA Demo.</p>
<pre><code>__int64 __fastcall main(int a1, char **a2, char **a3)
{
  ...
  ...
  timer = time(0LL);
  tp = localtime(&amp;timer);
  strftime(s, 0x32uLL, &quot;%Y-%m-%dT%H:%M:%S%Z&quot;, tp);
  strftime(nptr, 5uLL, &quot;%M&quot;, tp);
  v4 = atoi(nptr);
  dword_4100 = v4 % 6 + 2;
  v8 = v4 % 6 + 2;
  stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  if ( stream )
  {
    fgets(&amp;src, 50, stream);
    fclose(stream);
    for ( i = 0; i &lt; strlen(&amp;src); ++i )
    {
      if ( *(&amp;src + i) == 10 )
        *(&amp;src + i) = 0;
    }
    strncpy(&amp;dest, &amp;src, 0x32uLL);
    v12 = sub_12A9;
    v13 = sub_13DD;
    v14 = sub_1473;
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)v8 % 3))(&amp;dest, v8);
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)(v8 + 1) % 3))(&amp;dest, v8);
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)(v8 + 2) % 3))(&amp;dest, v8);
    printf(&quot;%s&gt; Encrypted password: %s\n&quot;, s, &amp;dest);
    fflush((FILE *)&amp;dword_0);
    printf(&quot;Enter the password: &quot;);
    fflush((FILE *)&amp;dword_0);
    fgets(byte_4104, 50, (FILE *)&amp;dword_0);
    for ( j = 0; j &lt; strlen(byte_4104); ++j )
    {
      if ( byte_4104[j] == 10 )
        byte_4104[j] = 0;
    }
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)v8 % 3))(byte_4104, v8);
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)(v8 + 1) % 3))(byte_4104, v8);
    ((void (__fastcall *)(char *, _QWORD))*(&amp;v12 + (int)(v8 + 2) % 3))(byte_4104, v8);
    sub_14FB(&amp;dest, byte_4104);
    result = 0LL;
  }
  else
  {
    puts(&quot;Flag.txt not found. Exiting...&quot;);
    result = 0LL;
  }
  return result;
}
</code></pre><p>As we can see there is a <code>v4</code> variable where this variable stores the value <em>&lsquo;minutes&rsquo;</em> of <code>localtime</code>. After that <code>v4</code> is calculated with mod 6 plus 2, as follows <code>v4% 6 + 2</code>. The results are stored on the <code>v8</code>.</p>
<p>In the next line there are three functions, namely <code>sub_12A9</code>, <code>sub_13DD</code>, and <code>sub_1473</code>. Where these three functions use the <em>flag</em> in <code>dest</code> and <code>v8</code>. At this point we can assume that <code>v8</code> is the <em>&lsquo;key&rsquo;</em>. These three functions will do the same thing in our input.</p>
<p>Let&rsquo;s look at the pseudocode again.</p>
<pre><code>size_t __fastcall sub_12A9(const char *a1, int a2)
{
  size_t result; // rax
  int i; // [rsp+1Ch] [rbp-14h]

  for ( i = 0; ; i += 3 )
  {
    result = strlen(a1);
    if ( i &gt;= result )
      break;
    if ( a1[i] &gt; 96 &amp;&amp; a1[i] &lt;= 122 )	// a - z
      a1[i] = (a1[i] - 84 + a2) % 26 + 97;
    if ( a1[i] &gt; 64 &amp;&amp; a1[i] &lt;= 90 )	// A - Z
      a1[i] = (a1[i] - 52 + a2) % 26 + 65;
  }
  return result;
}
</code></pre><p>Okay until here, don&rsquo;t confuse what the <code>sub_12A9</code> function actually does.</p>
<p>This is the form of the Caesar Cipher function that we usually encounter in CTF challenges in general. In this case <em>Caesar Cipher</em> looks very <em>&lsquo;mathematical&rsquo;</em>.</p>
<p>I will not explain in more detail about this, this <a href="https://www.dcode.fr/caesar-cipher"><em>Link</em></a> explains in detail about the workings of <em>Caesar Cipher</em>.</p>
<pre><code>unsigned __int64 __fastcall sub_13DD(const char *a1, int a2)
{
  ...
  ...
  v6 = __readfsqword(0x28u);
  strncpy(dest, a1, 0x32uLL);
  v4 = strlen(a1);
  for ( i = 0; i &lt; v4; ++i )
    a1[i] = dest[(i + a2) % v4];
  return __readfsqword(0x28u) ^ v6;
}
</code></pre><p>The function of <code>sub_13DD</code> is to make a shift for each character in <code>a1</code>, where the character shift distance is determined from <code>a2</code>.</p>
<pre><code>Example:
a1 = 'insomn14', a2 = 4;
The result will be : 'mn14inso'
</code></pre><pre><code>__int64 __fastcall sub_1473(const char *a1, char a2)
{
  ...
  ...
  v4 = strlen(a1);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i &gt;= v4 )
      break;
    if ( a1[i] &gt; 47 &amp;&amp; a1[i] &lt;= 57 )	// 0 - 9
      a1[i] += a2;
  }
  return result;
}
</code></pre><p>In the <code>sub_1473</code> function, each number character in <code>a1</code> will be added to <code>a2</code></p>
<p>There is a function I forgot to mention in the first <code>sub_14FB</code>.</p>
<pre><code>int __fastcall sub_14FB(const char *a1, const char *a2)
{
  if ( !strcmp(a1, a2) )
    printf(&quot;Correct! Here you go: gigem{%s}\n&quot;, &amp;src);
  else
    puts(&quot;Incorrect password! Try again.&quot;);
  return fflush((FILE *)&amp;dword_0);
}
</code></pre><p>After our flag and input go through the three previous functions, this function compares our input with the flag.</p>
<p>To solve this challenge, we can inverse each of the functions I explained earlier.</p>
<p>The following are the scripts that I made to solve the challenge.</p>
<pre><code>def dec3(a1, a2):
    a1 = bytearray(a1)
    v4 = len(a1)
    for i in range(v4):
        if a1[i] &gt; 47 and a1[i] &lt;= 64:
            a1[i] -= a2
        i += 1
    return a1

def dec2(a1, a2):
    a1 = bytearray(a1)
    new = ''
    v4 = len(a1)
    for i in range(v4):
        new += chr(a1[(i-a2)%v4])
    return new

def dec1(a1, a2):
    a1 = bytearray(a1)
    i = 0
    while(i &lt; len(a1)):
        if a1[i] &gt; 96 and a1[i] &lt;= 122:
            a1[i] = (a1[i] + 46 - a2) % 26 + 97
        if a1[i] &gt; 64 and a1[i] &lt;= 90:
            a1[i] = (a1[i] + 52 - a2) % 26 + 65
        i+=3
    return a1

mnt = input(&quot;Key : &quot;) % 6 + 2
dec = raw_input(&quot;Cipher : &quot;)
res = dec1(dec2(dec3(dec, mnt), mnt), mnt)
print &quot;Plantext :&quot;,res
</code></pre><p>Let&rsquo;s test our script on nc service.</p>
<pre><code># Terminal 1
➜  ABOUT_TIME  nc challenges.tamuctf.com 4321
2020-03-30T22:46:52WIB&gt; Encrypted password: nt=bMem6gxTap:=VH7tsTbO
Enter the password:

----------------------------------
# Open Terminal 2
➜  ABOUT_TIME python2 solver.py
Key : 46
Cipher : nt=bMem6gxTap:=VH7tsTbO
Plantext : 1tsAbOut7iMet0geTaw47CH

----------------------------------
# Back to Terminal 1
➜  ABOUT_TIME  nc challenges.tamuctf.com 4321
2020-03-30T22:46:52WIB&gt; Encrypted password: nt=bMem6gxTap:=VH7tsTbO
Enter the password: 1tsAbOut7iMet0geTaw47CH
Correct! Here you go: gigem{1tsAbOut7iMet0geTaw47CH}
</code></pre><p>FLAG: <code>gigem{1tsAbOut7iMet0geTaw47CH}</code></p>
<hr>
<h3 id="just_bc">JUST_BC</h3>
<pre><code>Description:


nc challenges.tamuctf.com 4932

File:
just-bc.bin

</code></pre><p>In the following challenge we are given <a href="https://github.com/insomn14/CTFtime2020/tree/master/TAMUctf_2020/Reversing/JUST_BC"><em>just-bc.bin</em></a> file and nc service files.</p>
<pre><code>➜  JUST_BC file just-bc.bin 
just-bc.bin: LLVM IR bitcode

➜  JUST_BC nc challenges.tamuctf.com 4932
Password: test
lmao nice try, but that's not it
</code></pre><p>Honestly I&rsquo;m not familiar with challenges like this, but it doesn&rsquo;t take too much time to complete this challenge.</p>
<p>After several hours of asking Google, I finally found this <a href="https://subscription.packtpub.com/book/application_development/9781785285981/1/ch01lvl1sec14/converting-llvm-bitcode-to-target-machine-assembly"><em>article</em></a>.</p>
<p>We can use the llc command to see the assembly code, if you use linux you can type the <code>man llc</code> command to find out more in detail.</p>
<pre><code>➜  JUST_BC llc just-bc.bin -o out.s

➜  JUST_BC ll
total 1,6M
-rwxr-xr-x 1 insomnia insomnia   48 Mar 30 23:01 connect.sh
-rwxr-xr-x 1 insomnia insomnia 261K Mar 19 04:38 just-bc.bin
-rw-r--r-- 1 insomnia insomnia 640K Mar 29 21:17 out.s
</code></pre><p>After opening the file out.s there are many assembly code instructions. From here I just need to find the String of <em>&lsquo;Password&rsquo;</em>. When I find the string at the same time I see a suspicious string.</p>
<pre><code>.Lanon.112aa5216417f3e30cbfa40815f3b444.61:
	.ascii	&quot;lmaoniceonebuddypalfriendolino&quot;  &lt;------------------- &quot;That string is what I mean&quot;
	.size	.Lanon.112aa5216417f3e30cbfa40815f3b444.61, 30

	.type	.Lanon.112aa5216417f3e30cbfa40815f3b444.62,@object # @anon.112aa5216417f3e30cbfa40815f3b444.62
.Lanon.112aa5216417f3e30cbfa40815f3b444.62:
	.ascii	&quot;src/main.rs&quot;
	.size	.Lanon.112aa5216417f3e30cbfa40815f3b444.62, 11

	.type	.Lanon.112aa5216417f3e30cbfa40815f3b444.63,@object # @anon.112aa5216417f3e30cbfa40815f3b444.63
	.p2align	3
.Lanon.112aa5216417f3e30cbfa40815f3b444.63:
	.quad	.Lanon.112aa5216417f3e30cbfa40815f3b444.62
	.asciz	&quot;\013\000\000\000\000\000\000\000\030\000\000\000!\000\000&quot;
	.size	.Lanon.112aa5216417f3e30cbfa40815f3b444.63, 24

	.type	.Lanon.112aa5216417f3e30cbfa40815f3b444.64,@object # @anon.112aa5216417f3e30cbfa40815f3b444.64
.Lanon.112aa5216417f3e30cbfa40815f3b444.64:
	.ascii	&quot;Password: &quot;
	.size	.Lanon.112aa5216417f3e30cbfa40815f3b444.64, 10

</code></pre><p>I just need to copy and paste the string and run it on the nc service, and see what I get.</p>
<pre><code>➜  JUST_BC nc challenges.tamuctf.com 4932
Password: lmaoniceonebuddypalfriendolino
gigem{hmm_yes_interesting_very_interesting}
</code></pre><p>FLAG: <code>gigem{hmm_yes_interesting_very_interesting}</code></p>
]]></content>
        </item>
        
        <item>
            <title>ÅngstromCTF 2020 | RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/%C3%A5ngstromctf-2020/</link>
            <pubDate>Thu, 19 Mar 2020 12:59:21 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/%C3%A5ngstromctf-2020/</guid>
            <description>Revving Up Description: Clam wrote a program for his school&#39;s cybersecurity club&#39;s first rev lecture! Can you get it to give you the flag? You can find it at /problems/2020/revving_up on the shell server, which you can access via the &amp;quot;shell&amp;quot; link at the top of the site. Hint : Try some google searches for &amp;quot;how to run a file in linux&amp;quot; or &amp;quot;bash for beginners&amp;quot;. File: revving_up Author: aplet123 In this challenge we are given the revving_up binary file.</description>
            <content type="html"><![CDATA[<hr>
<h3 id="revving-up">Revving Up</h3>
<pre><code>Description:
Clam wrote a program for his school's cybersecurity club's first rev lecture! Can you get it to give you the flag?
You can find it at /problems/2020/revving_up on the shell server,
which you can access via the &quot;shell&quot; link at the top of the site.

Hint : 
Try some google searches for &quot;how to run a file in linux&quot; or &quot;bash for beginners&quot;.

File:
revving_up

Author: 
aplet123
</code></pre><p>In this challenge we are given the <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/angstromctf_2020/Reverse/Revving%20Up">revving_up</a></em> binary file.</p>
<pre><code>❯ file revving_up
revving_up: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e9a5285cc0d71320a73e27870a35a98efbe01a87, not stripped

❯ ./revving_up
Congratulations on running the binary!
Now there are a few more things to tend to.
Please type &quot;give flag&quot; (without the quotes).
give flag
Good job!
Now run the program with a command line argument of &quot;banana&quot; and you'll be done!
❯ 
</code></pre><p>When we run the program we are asked to enter the input &lsquo;<em>give flag</em>&rsquo;. But in the next instruction we are asked to add the &lsquo;<em>banana</em>&rsquo; argument when executing the program. The following is the pseudocode, I use <em>radare2</em> with <em>r2ghidra-dec</em>.</p>
<pre><code>iVar2 = sym.imp.strcmp(&amp;s1, &quot;give flag&quot;);
    if (iVar2 == 0) {
        sym.imp.puts(&quot;Good job!&quot;);
        if ((int32_t)argc &lt; 2) {
            sym.imp.puts(&quot;Now run the program with a command line argument of \&quot;banana\&quot; and you\'ll be done!&quot;);
            uVar4 = 1;
        } else {
            iVar2 = sym.imp.strcmp(argv[1], &quot;banana&quot;);
            if (iVar2 == 0) {
                sym.imp.puts(&quot;Well I think it\'s about time you got the flag!&quot;);
                sym.print_flag();
                uVar4 = 0;
            } else {
                sym.imp.printf(&quot;You provided \&quot;%s\&quot;, not \&quot;banana\&quot;. Please try again.\n&quot;, argv[1]);
                uVar4 = 1;
            }
        }
</code></pre><p>As you can see, on the iVar2 variable there is <code>strcmp (argv [1], 'banana');</code> As we mentioned earlier we need to add an argument to the argument when executing the program. Now run the program on the given server ssh.</p>
<pre><code>team5385@actf:/problems/2020/revving_up$ ./revving_up banana
Congratulations on running the binary!
Now there are a few more things to tend to.
Please type &quot;give flag&quot; (without the quotes).
give flag
Good job!
Well I think it's about time you got the flag!
actf{g3tting_4_h4ng_0f_l1nux_4nd_b4sh}
</code></pre><p>FLAG : <code>actf{g3tting_4_h4ng_0f_l1nux_4nd_b4sh}</code></p>
<hr>
<h2 id="windows-of-opportunity">Windows of Opportunity</h2>
<pre><code>Description:
Clam's a windows elitist and he just can't stand seeing all of these linux challenges!
So, he decided to step in and create his own rev challenge with the &quot;superior&quot; operating system.

Hint : 
You can probably solve it just by looking at the disassembly.

File:
windows_of_opportunity.exe

Author: 
aplet123
</code></pre><p>In the following challenge we are given the file <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/angstromctf_2020/Reverse/Windows%20of%20Opportunity">windows_of_opportunity.exe</a></em>.</p>
<pre><code>❯ file windows_of_opportunity.exe
windows_of_opportunity.exe: PE32+ executable (console) x86-64, for MS Windows

❯ wine windows_of_opportunity.exe
Welcome to the superior rev challenge compiled for the superior operating system!
What's the superior flag for this superior rev challenge?
give flag
Your flag is way too different from my superior flag!
</code></pre><p>As <strong>Hint</strong> said, let&rsquo;s look at the <em>disassembly</em> code. Following is the <em>disassembly</em> code of <em>radare2</em>.</p>
<pre><code>...
│           0x00401603      ffd0           call rax
│           0x00401605      4989c0         mov r8, rax
│           0x00401608      ba80000000     mov edx, 0x80               ; 128 ; FILE *stream
│           0x0040160d      488d0d8c1a00.  lea rcx, [0x004030a0]       ; &quot;actf{ok4y_m4yb3_linux_is_s7ill_b3tt3r}&quot;
│           0x00401614      e8c7160000     call sym.fgets              ; char *fgets(char *s, int size, FILE *stream)
│           0x00401619      488d0d801a00.  lea rcx, [0x004030a0]       ; &quot;actf{ok4y_m4yb3_linux_is_s7ill_b3tt3r}&quot;
│           0x00401620      e87b160000     call sym.strlen             ; size_t strlen(const char *s)
│           0x00401625      83e801         sub eax, 1
│           0x00401628      8945f8         mov dword [var_8h], eax
│           0x0040162b      8b45f8         mov eax, dword [var_8h]
│           0x0040162e      4863d0         movsxd rdx, eax
│           0x00401631      488d05681a00.  lea rax, [0x004030a0]       ; &quot;actf{ok4y_m4yb3_linux_is_s7ill_b3tt3r}&quot;
│           0x00401638      c6040200       mov byte [rdx + rax], 0
│           0x0040163c      837df826       cmp dword [var_8h], 0x26
│       ┌─&lt; 0x00401640      7416           je 0x401658
│       │   0x00401642      488d0d4f2a00.  lea rcx, str.Your_flag_is_way_too_different_from_my_superior_flag ; 0x404098 ; &quot;Your flag is way too different from my superior flag!&quot;
│       │   0x00401649      e862160000     call sym.puts               ; int puts(const char *s)
│       │   0x0040164e      b901000000     mov ecx, 1
│       │   0x00401653      e890160000     call sym.exit
│       │   ; CODE XREF from sym.main @ 0x401640
...

[0x00401500]&gt; px 0x26 @ 0x004030a0
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x004030a0  6163 7466 7b6f 6b34 795f 6d34 7962 335f  actf{ok4y_m4yb3_
0x004030b0  6c69 6e75 785f 6973 5f73 3769 6c6c 5f62  linux_is_s7ill_b
0x004030c0  3374 7433 727d                           3tt3r}
</code></pre><p>We can immediately see the flag very clearly. The flag is located at memory address <em>0x004030a0</em>.</p>
<pre><code>❯ wine windows_of_opportunity.exe
Welcome to the superior rev challenge compiled for the superior operating system!
What's the superior flag for this superior rev challenge?
actf{ok4y_m4yb3_linux_is_s7ill_b3tt3r}
Oh wow a fellow windows user!
</code></pre><p>FLAG : <code>actf{ok4y_m4yb3_linux_is_s7ill_b3tt3r}</code></p>
<hr>
<h2 id="taking-off">Taking Off</h2>
<pre><code>Description:
So you started revving up, but is it enough to take off? Find the problem in /problems/2020/taking_off/ in the shell server.

Hint : 
You should look into tools like GHIDRA, *gdb*, and *objdump*.

File:
taking_off

Author: 
aplet123
</code></pre><p>In the following challenge we are given the binary <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/angstromctf_2020/Reverse/Taking%20Off">taking_off file</a></em>.</p>
<pre><code>❯ file taking_off
taking_off: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=fc4deaf2c2da6fdaf4cb7bc1e83d4f1372720832, not stripped

❯ ./taking_off
So you figured out how to provide input and command line arguments.
But can you figure out what input to provide?
Make sure you have the correct amount of command line arguments!
...
...
❯ ./taking_off aa bb cc dd
So you figured out how to provide input and command line arguments.
But can you figure out what input to provide?
Don't try to guess the arguments, it won't work.

</code></pre><p>Almost the same as the previous challenge, we are asked to execute the program with arguments. As you can see after we add as many as four arguments the program displays different outputs. Let&rsquo;s look at the pseudocode.</p>
<pre><code>[0x00400790]&gt; pdg@main
...
	if (argc == 5) {
		sym.string_to_int(argv[1], (int64_t)&amp;var_ach);
		sym.string_to_int(argv[2], (int64_t)&amp;var_ach + 4);
		sym.string_to_int(argv[3], (int64_t)&amp;var_a4h);
...

[0x00400790]&gt; pdg@sym.string_to_int

void sym.string_to_int(char *arg1, int64_t arg2)
{
    int64_t var_10h;
    char *s;
    
    sym.imp.sscanf(arg1, 0x400c8d, arg2);
    return;
}
</code></pre><p>As we can see there is a function <code>string_to_int (char * arg1, int64_t arg2)</code>, where it transforms our argument into an integer.</p>
<pre><code>[0x00400790]&gt; pdg@main
...
    iVar2 = sym.is_invalid((uint64_t)(uint32_t)var_ach);	
    if (iVar2 == 0) {
        iVar2 = sym.is_invalid((uint64_t)var_ach._4_4_);
        if (iVar2 == 0) {
            iVar2 = sym.is_invalid((uint64_t)var_a4h);
            if (iVar2 == 0) {
                if (var_a4h + var_ach._4_4_ * 100 + (uint32_t)var_ach * 10 == 0x3a4) {
                    iVar2 = sym.imp.strcmp(argv[4], &quot;chicken&quot;);
...
[0x00400790]&gt; pdg@sym.is_invalid

undefined8 sym.is_invalid(undefined8 arg1)
{
    undefined8 uVar1;
    undefined8 var_4h;
    
    if (((int32_t)arg1 &lt; 0) || (9 &lt; (int32_t)arg1)) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}
</code></pre><p>Next after changing our argument there is also the sym.is_invalid function (undefined8 arg1). The function aims to check whether our argument is smaller than 0 or greater than 9 then returns the value of uVar1.</p>
<pre><code>...
    if (var_a4h + var_ach._4_4_ * 100 + (uint32_t)var_ach * 10 == 0x3a4) {
        iVar2 = sym.imp.strcmp(argv[4], &quot;chicken&quot;);
        if (iVar2 == 0) {
            sym.imp.puts(&quot;Well, you found the arguments, but what\'s the password?&quot;);
...
</code></pre><p>Next there is the condition  <code>if (var_a4h + var_ach._4_4_ * 100 + (uint32_t)var_ach * 10 == 0x3a4)</code>. our three arguments after calculated the result must be equal to 932. And in the next line our fourth argument is chicken.</p>
<p>Here is a simple code to get to our three arguments.</p>
<pre><code>&gt;&gt;&gt;  for i in range(0, 10):
...		for j in range(0, 10):
...		     for k in range(0, 10):
...			  if 100 * j + 10 * i + k == 932:
...			       print (i, j ,k)
...			       break
... 
3 9 2
</code></pre><p>So our argument is <code>3 9 2 chicken</code>. Let&rsquo;s look at the following lines of code.</p>
<pre><code>...
    sym.imp.puts(&quot;Well, you found the arguments, but what\'s the password?&quot;);
    sym.imp.fgets(&amp;s, 0x80, _reloc.stdin);
    var_98h = (char *)sym.imp.strchr(&amp;s, 10);
    if (var_98h != (char *)0x0) {
        *var_98h = '\0';
    }
    var_9ch = sym.imp.strlen(&amp;s);
    var_a0h = 0;
    while (var_a0h &lt;= var_9ch) {
        if ((*(uint8_t *)((int64_t)&amp;s + (int64_t)var_a0h) ^ 0x2a) != &quot;ZFOKYO\nMC\\O\nLFKM*&quot;[var_a0h]) {
            sym.imp.puts(&quot;I\'m sure it\'s just a typo. Try again.&quot;);
            uVar3 = 1;
            goto code_r0x00400bc7;
        }
        var_a0h = var_a0h + 1;
    }
    sym.imp.puts(&quot;Good job! You\'re ready to move on to bigger and badder rev!&quot;);
    sym.print_flag();
    uVar3 = 0;
    goto code_r0x00400bc7;
...
</code></pre><p>In this section we are asked to enter a password, each character will be xor with 0x2a and the result must be the same as <code>ZFOKYO\nMC\\O\nLFKM*</code>. Let&rsquo;s make a simple code to guess the password.</p>
<pre><code>&gt;&gt;&gt; from string import printable
&gt;&gt;&gt; password = ''
&gt;&gt;&gt; res = &quot;ZFOKYO\nMC\\O\nLFKM*&quot;
&gt;&gt;&gt; for i in res:
...     for ch in printable:
...             if chr(ord(ch)^0x2a) == i:
...                     password += ch
... 
&gt;&gt;&gt; password
'please give flag'
</code></pre><p>Now that we know the password, it&rsquo;s time to prove. Let&rsquo;s run the program from the ssh server.</p>
<pre><code>team5385@actf:~$ cd /problems/2020/taking_off/
team5385@actf:/problems/2020/taking_off$ ./taking_off 3 9 2 chicken
So you figured out how to provide input and command line arguments.
But can you figure out what input to provide?
Well, you found the arguments, but what's the password?
please give flag
Good job! You're ready to move on to bigger and badder rev!
actf{th3y_gr0w_up_s0_f4st}
team5385@actf:/problems/2020/taking_off$ 
</code></pre><p>FLAG : <code>actf{th3y_gr0w_up_s0_f4st}</code></p>
<hr>
<h2 id="masochistic-sudoku">Masochistic Sudoku</h2>
<pre><code>Description:
Clam's tired of the ease and boredom of traditional sudoku. Having just one solution that can be determined via a simple online sudoku solver isn't good enough for him.
So, he made masochistic sudoku! Since there are no hints, there are around 6*10^21 possible solutions but only one is actually accepted!
Find it on the shell server at /problems/2020/masochistic_sudoku/.

File:
masochistic_sudoku

Author: 
aplet123
</code></pre><p>In the following problem we are given the <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/angstromctf_2020/Reverse/Masochistic%20Sudoku">masochistic_sudoku</a></em> binary file.</p>
<pre><code>❯ file masochistic_sudoku
masochistic_sudoku: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d812dc3b76f3241ad03e6018d45d1d18665ce1dd, not stripped
❯ ./masochistic_sudoku
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
</code></pre><p>This challenge is very interesting, so I need IDA to debug. When after opening it with IDA there are very many instructions, but there is a function that interests me, the <em>check_flag</em> function.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-19%2022-49-53.png" alt="check_flag" title="check_flag"></p>
<p>Following is the pseudocode of the <em>check_flag</em> function.</p>
<pre><code>...
...
  v0 = gen_value(0LL, 0LL, (unsigned int)board[0]);
  assert(v0 == 1754831936);
  v1 = gen_value(0LL, 4LL, (unsigned int)dword_603170);
  assert(v1 == 1322670498);
  v2 = gen_value(0LL, 6LL, (unsigned int)dword_603178);
  assert(v2 == 2075469024);
  v3 = gen_value(0LL, 7LL, (unsigned int)dword_60317C);
  assert(v3 == 1924349448);
  v4 = gen_value(1LL, 2LL, (unsigned int)dword_60318C);
  assert(v4 == 1737338032);
  v5 = gen_value(1LL, 4LL, (unsigned int)dword_603194);
  assert(v5 == 382094521);
  v6 = gen_value(1LL, 5LL, (unsigned int)dword_603198);
  assert(v6 == 2003484635);
  v7 = gen_value(1LL, 6LL, (unsigned int)dword_60319C);
  assert(v7 == 1224890436);
  v8 = gen_value(2LL, 4LL, (unsigned int)dword_6031B8);
  assert(v8 == 613863398);
  v9 = gen_value(2LL, 5LL, (unsigned int)dword_6031BC);
  assert(v9 == 2131248558);
  v10 = gen_value(2LL, 7LL, (unsigned int)dword_6031C4);
  assert(v10 == 1855404474);
...
...
</code></pre><pre><code>int __fastcall gen_value(int a1, int a2, int a3)
{
  srand(13 * ((100 * a1 + 10 * a2 + a3) ^ 0x2A) % 10067);
  return rand();
}
</code></pre><p>And there is also the gen_value function. To understand what happens to the <em>check_flag</em> function, let&rsquo;s place breakpoints in the <em>check_flag</em> function and press the F9 key until we hit breakpoint.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-19%2022-52-06.png" alt="break_check_flag" title="break_check_flag"></p>
<p>Following is the technique that I use to find out the value of each box that will go through the <em>gen_value</em> function:</p>
<ol>
<li>
<p>Fill every 6 squares with numbers 1 through 9</p>
</li>
<li>
<p>View changes that occur in the .bss stack</p>
</li>
<li>
<p>Repeat the first and second steps, until the last 6 squares</p>
</li>
</ol>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Color%20Screenshot%20from%202020-03-19%2023-05-54.jpg" alt="sudoku" title="sudoku"></p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-19%2023-11-25.png" alt="Sudoku" title="Sudoku"></p>
<p>Following are my observations, the numbers represent that the values ​​contained in the box will be used as parameters in the <em>gen_value</em> function.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-19%2023-54-37.png" alt="Sudoku" title="Sudoku"></p>
<p>Let&rsquo;s create a script to find a suitable value to match in each box that we find.</p>
<pre><code>from ctypes import *

libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libdl.so.2&quot;)

def gen_value(a1,a2,parm):
    for num in range(1,10):
        libc.srand((13 * ((100 * a1 + 10 * a2 + num) ^ 42) % 10067))
        res = libc.rand()
        if res == parm:
            return num
    return None

def main():
    val = [1754831936, 1322670498, 2075469024, 1924349448, 1737338032, 382094521, 2003484635, 1224890436, 613863398, 2131248558, 1855404474, 203716718, 2132752585, 54194304, 548400147, 2040844259, 348846481, 712829567, 198917626, 1999818593, 47214827, 117615071, 1948118465, 345110140, 2113220118, 443730372, 2136198019, 1427855150, 323649682, 1443247958]
    
    guess = [0 for _ in range(30)]
    guess[0] = gen_value(0,0,val[0])
    guess[1] = gen_value(0,4,val[1])
    guess[2] = gen_value(0,6,val[2])
    guess[3] = gen_value(0,7,val[3])
    guess[4] = gen_value(1,2,val[4])
    guess[5] = gen_value(1,4,val[5])
    guess[6] = gen_value(1,5,val[6])
    guess[7] = gen_value(1,6,val[7])
    guess[8] = gen_value(2,4,val[8])
    guess[9] = gen_value(2,5,val[9])
    guess[10] = gen_value(2,7,val[10])
    guess[11] = gen_value(3,0,val[11])
    guess[12] = gen_value(3,2,val[12])
    guess[13] = gen_value(4,0,val[13])
    guess[14] = gen_value(4,1,val[14])
    guess[15] = gen_value(4,7,val[15])
    guess[16] = gen_value(4,8,val[16])
    guess[17] = gen_value(5,6,val[17])
    guess[18] = gen_value(5,8,val[18])
    guess[19] = gen_value(6,1,val[19])
    guess[20] = gen_value(6,3,val[20])
    guess[21] = gen_value(6,4,val[21])
    guess[22] = gen_value(7,2,val[22])
    guess[23] = gen_value(7,3,val[23])
    guess[24] = gen_value(7,4,val[24])
    guess[25] = gen_value(7,6,val[25])
    guess[26] = gen_value(8,1,val[26])
    guess[27] = gen_value(8,2,val[27])
    guess[28] = gen_value(8,4,val[28])
    guess[29] = gen_value(8,8,val[29])
    for i,j in enumerate(guess):
        print(f'Guess: {j} --&gt; Val: {val[i]}')
      
if __name__ == '__main__':
    main()
</code></pre><p>Output :</p>
<pre><code>Guess: 1 --&gt; Val: 1754831936    // (1,1)
Guess: 6 --&gt; Val: 1322670498    // (2,2)
Guess: 8 --&gt; Val: 2075469024    // (3,1)
Guess: 5 --&gt; Val: 1924349448    // (3,2)
Guess: 5 --&gt; Val: 1737338032    // (1,5)
Guess: 8 --&gt; Val: 382094521     // (3,4)
Guess: 3 --&gt; Val: 2003484635    // (2,6)
Guess: 1 --&gt; Val: 1224890436    // (3,4)
Guess: 1 --&gt; Val: 613863398     // (2,8)
Guess: 2 --&gt; Val: 2131248558    // (2,9)
Guess: 9 --&gt; Val: 1855404474    // (3,8)
Guess: 9 --&gt; Val: 203716718     // (4,1)
Guess: 7 --&gt; Val: 2132752585    // (4,3)
Guess: 5 --&gt; Val: 54194304      // (4,4)
Guess: 3 --&gt; Val: 548400147     // (4,5)
Guess: 8 --&gt; Val: 2040844259    // (6,5)
Guess: 9 --&gt; Val: 348846481     // (6,6)
Guess: 3 --&gt; Val: 712829567     // (6,7)
Guess: 5 --&gt; Val: 198917626     // (6,9)
Guess: 4 --&gt; Val: 1999818593    // (7,2)
Guess: 6 --&gt; Val: 47214827      // (8,1)
Guess: 2 --&gt; Val: 117615071     // (8,2)
Guess: 6 --&gt; Val: 1948118465    // (7,6)
Guess: 1 --&gt; Val: 345110140     // (8,4)
Guess: 9 --&gt; Val: 2113220118    // (8,5)
Guess: 7 --&gt; Val: 443730372     // (9,4)
Guess: 2 --&gt; Val: 2136198019    // (7,8)
Guess: 1 --&gt; Val: 1427855150    // (7,9)
Guess: 3 --&gt; Val: 323649682     // (8,8)
Guess: 4 --&gt; Val: 1443247958    // (9,9)
</code></pre><p>After we get the value, then enter each value into the box that we found earlier.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-20%2000-16-52.png" alt="Found_value" title="Found_value"></p>
<p>Now is the time to fill in the empty boxes. There are three ways to solve it.</p>
<ol>
<li>
<p><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">Using z3-Solver.</a></p>
</li>
<li>
<p><a href="https://anysudokusolver.com/">Using Sudoku Solver.</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">Using our brain.</a></p>
</li>
</ol>
<p>I prefer to use number 2.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-20%2000-31-50.png" alt="final" title="final"></p>
<p>Then press q.</p>
<p><img src="/img/Screenshot/%C3%85ngstromCTF%202020/Screenshot%20from%202020-03-20%2000-32-28.png" alt="final" title="final"></p>
<p>Now we prove it on ssh server.</p>
<pre><code>team5385@actf:~$ cd /problems/2020/masochistic_sudoku/
team5385@actf:/problems/2020/masochistic_sudoku$ ./masochistic_sudoku 
Wow you're good at sudoku!
actf{sud0ku_but_f0r_pe0ple_wh0_h4te_th3mselves}
team5385@actf:/problems/2020/masochistic_sudoku$ 
</code></pre><p>FLAG : <code>actf{sud0ku_but_f0r_pe0ple_wh0_h4te_th3mselves}</code></p>
]]></content>
        </item>
        
        <item>
            <title>NeverLAN CTF 2020 |  RE *Writeups*</title>
            <link>https://insomn14.github.io/posts/neverlanctf-2020/</link>
            <pubDate>Fri, 14 Feb 2020 00:46:37 +0700</pubDate>
            
            <guid>https://insomn14.github.io/posts/neverlanctf-2020/</guid>
            <description>Script Kiddie 100pts Description: It looks like a script kiddie was trying to build a crypto locker. See if you can get the database back? File: encrypted_db This problem gives us the encrypted_db file, you can download it on my github. After that we can see the file format using the following command.
❯ file encrypted_db encrypted_db: ASCII text This file has a text format, let&amp;rsquo;s look at the contents of the file.</description>
            <content type="html"><![CDATA[<hr>
<h3 id="script-kiddie-100pts">Script Kiddie 100pts</h3>
<pre><code>Description:
It looks like a script kiddie was trying to build a crypto locker.
See if you can get the database back?
File:
encrypted_db
</code></pre><p>This problem gives us the <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/NeverLAN-CTF/Re/ScriptKiddie">encrypted_db</a></em> file, you can download it on my github. After that we can see the file format using the following command.</p>
<pre><code>❯ file encrypted_db
encrypted_db: ASCII text
</code></pre><p>This file has a text format, let&rsquo;s look at the contents of the file.</p>
<pre><code>❯ cat encrypted_db
..... 
764c6d4e7662534973496d466b5a484a6c63334d694f6e7369633352795a
5756300a496a6f69516d396e61584e705932676754576c7a63326c766269
4973496e4e316158526c496a6f69515842304c6941344e4441694c434a6a
61585235496a6f69536d4635626d566962334a760a6457646f4969776965
6d6c775932396b5a534936496a63784e6a4d33496977695a325676496a70
37496d786864434936496a4d7a4c6a45794d6a4d694c434a73626d63694f
.....
</code></pre><p>After opening the file I thought that it had been encoded into the hex form. I use python2 interactive to decode the contents of the file.</p>
<pre><code>&gt;&gt;&gt; enc = open('encrypted_db', 'r').read().replace('\n','')
&gt;&gt;&gt; dec = enc.decode('hex')
&gt;&gt;&gt; dec
....
....
ZGVyIC0gSmFjb2JpIiwiY2F0\nY2hQaHJhc2UiOiJDdXN0b21pemFibGUgb3B0aW1pemluZyBpbnRlcmZhY2UiLCJicyI6ImUtYnVz\naW5lc3Mgc3ludGhlc2l6ZSBzY2hlbWFzIn19fQo=\n'

</code></pre><p>As you can see, we get lots of random characters. If we look closer to the last line, there is the character <em>'='</em> so I&rsquo;m guessing maybe this is base64. Let&rsquo;s make a simple code to solve this challange.</p>
<pre><code>❯ nl solver.py
     1	import re
     2	from base64 import b64decode
       
     3	enc = open('encrypted_db', 'r').read().replace('\n', '')
     4	dec = b64decode(enc.decode('hex'))
     5	print re.findall(r'flag[^.]*}', dec)
     
❯ python solver.py
['flag{ENC0D1NG_D4TA_1S_N0T_ENCRY7I0N}']

</code></pre><p>And we got the flag.</p>
<p><code>flag{ENC0D1NG_D4TA_1S_N0T_ENCRY7I0N}</code></p>
<hr>
<h3 id="adobe-payroll-100pts">Adobe Payroll 100pts</h3>
<pre><code>Description:
We've forgotten the password to our payroll machine. Can you extract it?
File:
Adobe_Payroll.7z
</code></pre><p>Almost the same as the previous challange, in this problem we were given <em><a href="https://github.com/insomn14/CTFtime2020/tree/master/NeverLAN-CTF/Re/AdobePlayroll">Adobe_Payroll.7z</a></em>,
you can download the file on my github. Let&rsquo;s extract the <em>7z</em> file, in the <em>7z</em> file there are two files, including the  <em>executable</em> file and <em>description.md</em>.</p>
<pre><code>❯ file Adobe_Employee_Payroll.exe
Adobe_Employee_Payroll.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows

❯ cat description.md
# Adobe Payroll

- Category: I promise it's not malware 😈
- Points: 100

## Description

This is a .NET file. Take a look at dotPeek.
</code></pre><p>So basically, I think this program uses C# language. So you can use <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi7o_PPwM_nAhX4yDgGHYAjCVAQFjAEegQIDBAG&amp;url=https%3A%2F%2Fwww.jetbrains.com%2Fdecompiler%2F&amp;usg=AOvVaw1pcfEbCKhdDrtRMXeXhm3k">dotPeek</a>   to decompile. But in this case I use IDA to do static analysis.
<img src="/img/Screenshot/neverlanctf2020/Re/3.PNG" alt="AdobePayroll">
Select <code>Microsoft.Net assembly [pe.ldw]</code> then click Ok.
<img src="/img/Screenshot/neverlanctf2020/Re/4.PNG" alt="AdobePayroll">
In the <em>Functions window</em> there is a function of <code>employee_payroll_checkUsername</code> &amp; <code>employee_payroll_chackPassword</code>, That function I think is used to compare a string.
<img src="/img/Screenshot/neverlanctf2020/Re/5.PNG" alt="AdobePayroll">
<img src="/img/Screenshot/neverlanctf2020/Re/6.PNG" alt="AdobePayroll">
Let&rsquo;s try using the <code>admin</code> as the <em>Username</em> and <code>bmV2ZXJfZ29ubmFfZ212ZV95b3VfdXAh</code> as the <em>Password</em>.
<img src="/img/Screenshot/neverlanctf2020/Re/flag.PNG" alt="AdobePayroll">
And boom!.. we got the flag.</p>
<p><code>flag{.net_is_pretty_eassy_to_decompile}</code></p>
<hr>
<h3 id="reverse-engineer-300pts">Reverse Engineer 300pts</h3>
<pre><code>Description:
This program seems to get stuck while running...
Can you get it to continue past the broken function?
File:
reverseng
</code></pre><p>In this case we are given a binary <a href="https://github.com/insomn14/CTFtime2020/tree/master/NeverLAN-CTF/Re/Reverse%20Engineer">reverseng</a>  file, once again you can check on my github to download the binary file ;). when we try to run the program we will get the SEGV message.</p>
<pre><code>❯ ./revseng
[1]    12675 segmentation fault (core dumped)  ./revseng

❯ file revseng
revseng: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=89d54c514d9f6bec697e52edfee4a495266b3577, for GNU/Linux 3.2.0, with debug_info, not stripped
</code></pre><p>So without further ado let&rsquo;s get started analyzing it using IDA. There is a function called <code>void __cdecl print ()</code> and <code>malloc ()</code> function that allocates memory of 0x15 or 21byte to <code>flg</code>, And each byte contains a decimal value. So this is the Pseudocode of the function, after we convert each index value of <code>flg</code> to character.</p>
<p><img src="/img/Screenshot/neverlanctf2020/Re/pseudocode.png" alt="revseng"></p>
<p>And we get the flag again.</p>
<p><code>flag{w3con7r0lth3b1nari3s}</code></p>
]]></content>
        </item>
        
    </channel>
</rss>
